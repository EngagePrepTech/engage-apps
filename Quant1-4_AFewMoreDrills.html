<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fundamentals Drills - Engage Prep</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #014C6A;
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 1.5rem 1rem;
        }
        
        .container {
            max-width: 500px;
            margin: 0 auto;
            flex: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
        }
        
        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }
        
        .header-logo {
            width: 44px;
            height: 44px;
        }
        
        h1 {
            font-size: 1.3rem;
            font-weight: 600;
        }
        
        h2 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        /* Menu Styles */
        .menu-section {
            margin-bottom: 2rem;
        }
        
        .drill-options {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .drill-option {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .drill-option:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.4);
        }
        
        .drill-option.selected {
            background: rgba(34, 197, 94, 0.2);
            border-color: #22c55e;
        }
        
        .drill-option input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #22c55e;
        }
        
        .drill-option label {
            cursor: pointer;
            flex: 1;
        }
        
        .drill-option .drill-name {
            font-weight: 600;
        }
        
        .drill-option .drill-desc {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 0.25rem;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1.25rem 0 0.5rem 0;
            cursor: pointer;
        }
        
        .section-header:first-child {
            margin-top: 0;
        }
        
        .section-title {
            font-size: 0.85rem;
            text-transform: uppercase;
            opacity: 0.7;
            letter-spacing: 0.05em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .section-toggle {
            transition: transform 0.2s;
        }
        
        .section-header.collapsed .section-toggle {
            transform: rotate(-90deg);
        }
        
        .drill-options {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.2s ease;
        }
        
        .drill-options.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0;
        }
        
        .select-all-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 0.3rem 0.75rem;
            font-size: 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .select-all-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.5);
        }
        
        .mode-selection {
            margin: 1.5rem 0;
        }
        
        .mode-toggle {
            display: flex;
            justify-content: center;
            gap: 0;
            margin-bottom: 1rem;
        }
        
        .mode-btn {
            padding: 0.5rem 1.5rem;
            font-size: 0.9rem;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .mode-btn:first-child {
            border-radius: 6px 0 0 6px;
            border-right: 1px solid rgba(255,255,255,0.3);
        }
        
        .mode-btn:last-child {
            border-radius: 0 6px 6px 0;
            border-left: 1px solid rgba(255,255,255,0.3);
        }
        
        .mode-btn.active {
            background: rgba(34, 197, 94, 0.3);
            border-color: #22c55e;
            color: #fff;
        }
        
        .mode-options {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }
        
        .mode-options label {
            font-size: 0.9rem;
        }
        
        .mode-options select {
            padding: 0.5rem 1rem;
            font-size: 1rem;
            border-radius: 6px;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1);
            color: #fff;
            cursor: pointer;
        }
        
        .mode-options select option {
            background: #014C6A;
            color: #fff;
        }
        
        .start-btn {
            background: #22c55e;
            color: #000;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            margin-top: 1rem;
        }
        
        .start-btn:hover {
            background: #16a34a;
            color: #fff;
        }
        
        .start-btn:disabled {
            background: rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.5);
            cursor: not-allowed;
        }
        
        /* Drill Styles */
        .stats {
            display: flex;
            justify-content: center;
            gap: 3rem;
            margin-bottom: 1.5rem;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
        }
        
        .stat-label {
            font-size: 0.75rem;
            opacity: 0.7;
            text-transform: uppercase;
        }
        
        .problem {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            margin: 1.5rem 0;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        }
        
        .input-section {
            text-align: center;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .answer-input {
            width: 150px;
            padding: 1rem;
            font-size: 1.5rem;
            text-align: center;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        }
        
        .answer-input:focus {
            outline: none;
            border-color: #22c55e;
        }
        
        .answer-input:disabled {
            opacity: 0.5;
        }
        
        /* Two-box inputs */
        .two-box-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .small-input {
            width: 80px;
            padding: 0.75rem;
            font-size: 1.3rem;
        }
        
        .exp-caret {
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        .range-label {
            font-size: 1.1rem;
            opacity: 0.8;
        }
        
        /* Multiple choice */
        .mc-options {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            max-width: 300px;
            margin: 0 auto;
        }
        
        .mc-btn {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 1.25rem;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            font-size: 1.1rem;
        }
        
        .mc-btn:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.4);
        }
        
        .mc-btn.selected {
            background: rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
        }
        
        .mc-btn.correct {
            background: rgba(34, 197, 94, 0.3);
            border-color: #22c55e;
        }
        
        .mc-btn.wrong {
            background: rgba(239, 68, 68, 0.3);
            border-color: #ef4444;
        }
        
        .mc-btn:disabled {
            cursor: default;
        }
        
        .mc-letter {
            font-weight: bold;
            min-width: 1.5rem;
        }
        
        .mc-text {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        }
        
        .result {
            margin: 1rem 0;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            font-weight: 600;
        }
        
        .result.correct {
            background: rgba(34, 197, 94, 0.3);
            color: #22c55e;
        }
        
        .result.wrong {
            background: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }
        
        .solution {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 1.1rem;
            line-height: 1.8;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
            width: 100%;
            box-sizing: border-box;
        }
        
        .solution-inner {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 100%;
            overflow-wrap: break-word;
        }
        
        .solution-line {
            white-space: pre-wrap;
            word-wrap: break-word;
            max-width: 100%;
            text-align: center;
        }
        
        .solution .divider {
            border-bottom: 2px solid rgba(255,255,255,0.4);
            margin: 0.3rem 0;
            align-self: flex-end;
        }
        
        .solution .answer-final {
            color: #22c55e;
            font-weight: bold;
        }
        
        .hint-text {
            text-align: center;
            opacity: 0.6;
            font-style: italic;
            font-family: system-ui, -apple-system, sans-serif;
            width: 100%;
        }
        
        .continue-btn, .back-btn {
            background: #22c55e;
            color: #000;
            border: none;
            padding: 0.75rem 2rem;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 1rem;
        }
        
        .continue-btn:hover, .back-btn:hover {
            background: #16a34a;
            color: #fff;
        }
        
        .back-btn {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }
        
        .back-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        /* Footer */
        .footer {
            text-align: center;
            padding-top: 2rem;
            margin-top: auto;
        }
        
        .footer-logo {
            height: 40px;
            width: auto;
            margin-bottom: 0.5rem;
        }
        
        .footer-copyright {
            font-size: 0.65rem;
            opacity: 0.5;
        }
        
        /* Screen visibility */
        .screen {
            display: none;
        }
        
        .screen.active {
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        
        /* Multi-select styles */
        .multi-select-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            max-width: 400px;
            margin: 0 auto 1rem auto;
        }
        
        .ms-btn {
            padding: 0.75rem 1.25rem;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 1.2rem;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 70px;
        }
        
        .ms-btn:hover:not(:disabled) {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.4);
        }
        
        .ms-btn.selected {
            background: rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
        }
        
        .ms-btn.correct {
            background: rgba(34, 197, 94, 0.3);
            border-color: #22c55e;
        }
        
        .ms-btn.wrong {
            background: rgba(239, 68, 68, 0.3);
            border-color: #ef4444;
        }
        
        .ms-btn.missed {
            background: rgba(251, 191, 36, 0.3);
            border-color: #fbbf24;
        }
        
        .ms-btn:disabled {
            cursor: not-allowed;
        }
        
        .submit-btn {
            background: #3b82f6;
            color: #fff;
            border: none;
            padding: 0.75rem 2rem;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 0.5rem;
        }
        
        .submit-btn:hover {
            background: #2563eb;
        }
        
        .submit-btn:disabled {
            background: rgba(255,255,255,0.2);
            cursor: not-allowed;
        }
        
        /* Flashcard styles */
        .flashcard-prompt {
            font-size: 1.1rem;
            opacity: 0.8;
            margin-bottom: 1rem;
        }
        
        .reveal-btn {
            background: #8b5cf6;
            color: #fff;
            border: none;
            padding: 1rem 2.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 1rem;
        }
        
        .reveal-btn:hover {
            background: #7c3aed;
        }
        
        .flashcard-answer {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 1.3rem;
        }
        
        .self-grade-btns {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .grade-btn {
            padding: 0.75rem 2rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        
        .grade-btn.got-it {
            background: #22c55e;
            color: #000;
        }
        
        .grade-btn.got-it:hover {
            background: #16a34a;
            color: #fff;
        }
        
        .grade-btn.missed-it {
            background: #ef4444;
            color: #fff;
        }
        
        .grade-btn.missed-it:hover {
            background: #dc2626;
        }
        
        .result.partial {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }
        
        /* Fraction problem display */
        .fraction-problem {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 2rem;
            text-align: center;
            margin: 1rem 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        
        .frac {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            vertical-align: middle;
        }
        
        .frac-num, .frac-den {
            padding: 0.1em 0.3em;
        }
        
        .frac-bar {
            width: 100%;
            height: 3px;
            background: #fff;
            min-width: 2ch;
        }
        
        .op {
            font-size: 1.5rem;
            padding: 0 0.25rem;
        }
        
        /* Repeating decimal overline */
        .repeating {
            text-decoration: overline;
        }
        
        /* Solution fraction display */
        .solution-fractions {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            flex-wrap: wrap;
        }
        
        .sol-frac {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            vertical-align: middle;
            font-size: 1.1rem;
        }
        
        .sol-frac.final {
            color: #22c55e;
            font-weight: bold;
        }
        
        .sol-num, .sol-den {
            padding: 0.1em 0.2em;
            min-width: 1.5ch;
            text-align: center;
        }
        
        .sol-bar {
            width: 100%;
            height: 2px;
            background: currentColor;
            min-width: 1.5ch;
        }
        
        .solution-op {
            font-size: 1rem;
            padding: 0 0.2rem;
            opacity: 0.8;
        }
        
        .cancelled {
            text-decoration: line-through;
            opacity: 0.5;
            margin-right: 0.2em;
        }
        
        .new-val {
            color: #fbbf24;
        }
        
        .divide-by {
            font-size: 0.9rem;
            color: #fbbf24;
            padding: 0.2rem 0.4rem;
            background: rgba(251, 191, 36, 0.15);
            border-radius: 4px;
        }
        
        .multiply-by {
            font-size: 0.9rem;
            color: #4ade80;
            padding: 0.2rem 0.4rem;
            background: rgba(74, 222, 128, 0.15);
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 id="pageTitle" style="text-align: center; font-size: 1.3rem; margin-bottom: 1.5rem;">Fundamentals Drills</h1>
        
        <!-- MENU SCREEN -->
        <div class="screen active" id="menuScreen">
            <div class="menu-section">
                <p style="text-align: center; margin-bottom: 1.5rem; line-height: 1.5;">
                    Try 5-10 minutes of drills to practice what we just covered.<br>
                    <em>(Mix it up or focus on what needs more practice.)</em>
                </p>

                <!-- TOPICS SECTION -->
                <div class="section-header" data-section="topics">
                    <span class="section-title">
                        <span class="section-toggle">▼</span>
                        Topics
                    </span>
                    <button class="select-all-btn" data-section="topics">Select All</button>
                </div>
                <div class="drill-options" data-section="topics">
                    <div class="drill-option" data-drill="fractions">
                        <input type="checkbox" id="drill-fractions" value="fractions">
                        <label for="drill-fractions">
                            <div class="drill-name">Fraction Mechanics</div>
                            <div class="drill-desc">Reduce, add, subtract, multiply, divide</div>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="mode-selection">
                <div class="mode-toggle">
                    <button class="mode-btn active" id="modeQuestions">By Questions</button>
                    <button class="mode-btn" id="modeTime">By Time</button>
                </div>
                
                <div class="mode-options" id="questionOptions">
                    <label for="numQuestions">Number of questions:</label>
                    <select id="numQuestions">
                        <option value="5">5</option>
                        <option value="10" selected>10</option>
                        <option value="15">15</option>
                        <option value="20">20</option>
                    </select>
                </div>
                
                <div class="mode-options" id="timeOptions" style="display: none;">
                    <label for="timeLimit">Time limit:</label>
                    <select id="timeLimit">
                        <option value="120">2 minutes</option>
                        <option value="180">3 minutes</option>
                        <option value="300" selected>5 minutes</option>
                        <option value="600">10 minutes</option>
                    </select>
                </div>
            </div>
            
            <button class="start-btn" id="startBtn" disabled>Start Drill</button>
        </div>
        
        <!-- DRILL SCREEN -->
        <div class="screen" id="drillScreen">
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="correctCount">0</div>
                    <div class="stat-label">Correct</div>
                </div>
                <div class="stat" id="remainingStat">
                    <div class="stat-value" id="remaining">10</div>
                    <div class="stat-label">Remaining</div>
                </div>
                <div class="stat" id="timerStat" style="display: none;">
                    <div class="stat-value" id="timerDisplay">0:00</div>
                    <div class="stat-label">Time</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="wrongCount">0</div>
                    <div class="stat-label">Wrong</div>
                </div>
            </div>
            
            <div class="problem" id="problem">---</div>
            <div class="data-set" id="dataSet" style="display: none; font-family: monospace; font-size: 1.2rem; margin: 0.5rem 0; opacity: 0.9;"></div>
            <div class="fraction-problem" id="fractionProblem" style="display: none;"></div>
            
            <div class="input-section">
                <!-- Single input (default) -->
                <div id="singleInputDiv">
                    <input type="text" class="answer-input" id="answerInput" inputmode="numeric" autocomplete="off">
                </div>
                
                <!-- Fraction input (numerator / denominator) -->
                <div id="fractionInputDiv" style="display: none;">
                    <div class="two-box-container" style="flex-direction: column; gap: 0;">
                        <input type="text" class="answer-input small-input" id="numeratorInput" inputmode="numeric" autocomplete="off" style="border-bottom: none; border-radius: 8px 8px 0 0;">
                        <div style="width: 80px; height: 2px; background: white;"></div>
                        <input type="text" class="answer-input small-input" id="denominatorInput" inputmode="numeric" autocomplete="off" style="border-top: none; border-radius: 0 0 8px 8px;">
                    </div>
                </div>
                
                <!-- Two-box input for base^exponent -->
                <div id="twoBoxExpDiv" style="display: none;">
                    <div class="two-box-container">
                        <input type="text" class="answer-input small-input" id="baseInput" inputmode="numeric" autocomplete="off" placeholder="base">
                        <span class="exp-caret">^</span>
                        <input type="text" class="answer-input small-input" id="expInput" inputmode="numeric" autocomplete="off" placeholder="exp">
                    </div>
                </div>
                
                <!-- Two-box input for "between X and Y" -->
                <div id="twoBoxRangeDiv" style="display: none;">
                    <div class="two-box-container">
                        <input type="text" class="answer-input small-input" id="rangeLowInput" inputmode="numeric" autocomplete="off">
                        <span class="range-label">to</span>
                        <input type="text" class="answer-input small-input" id="rangeHighInput" inputmode="numeric" autocomplete="off">
                    </div>
                </div>
                
                <!-- Multiple choice -->
                <div id="multipleChoiceDiv" style="display: none;">
                    <div class="mc-options">
                        <button class="mc-btn" data-choice="A"><span class="mc-letter">A</span><span class="mc-text" id="choiceA"></span></button>
                        <button class="mc-btn" data-choice="B"><span class="mc-letter">B</span><span class="mc-text" id="choiceB"></span></button>
                        <button class="mc-btn" data-choice="C"><span class="mc-letter">C</span><span class="mc-text" id="choiceC"></span></button>
                        <button class="mc-btn" data-choice="D"><span class="mc-letter">D</span><span class="mc-text" id="choiceD"></span></button>
                        <button class="mc-btn" data-choice="E"><span class="mc-letter">E</span><span class="mc-text" id="choiceE"></span></button>
                    </div>
                </div>
                
                <!-- Multi-select -->
                <div id="multiSelectDiv" style="display: none;">
                    <div class="multi-select-options" id="msOptions"></div>
                    <button class="submit-btn" id="msSubmitBtn">Check Answer</button>
                </div>
                
                <!-- Flashcard / self-grade -->
                <div id="flashcardDiv" style="display: none;">
                    <div class="flashcard-prompt">Work it out, then reveal the answer.</div>
                    <button class="reveal-btn" id="revealBtn">Reveal Answer</button>
                    <div class="flashcard-answer" id="flashcardAnswer" style="display: none;"></div>
                    <div class="self-grade-btns" id="selfGradeBtns" style="display: none;">
                        <button class="grade-btn got-it" id="gotItBtn">Got it ✓</button>
                        <button class="grade-btn missed-it" id="missedItBtn">Missed it ✗</button>
                    </div>
                </div>
                
                <div class="result" id="result" style="display: none;"></div>
                
                <div class="solution" id="solution">
                    <span class="hint-text">Enter your answer above and press Enter.</span>
                </div>
                
                <button class="continue-btn" id="continueBtn" style="display: none;">Next Question →</button>
            </div>
        </div>
        
        <!-- RESULTS SCREEN -->
        <div class="screen" id="resultsScreen">
            <div class="results-content" style="text-align: center; padding: 2rem 0;">
                <h2 style="font-size: 2rem; margin-bottom: 1rem;">Done!</h2>
                <p id="finalScore" style="font-size: 1.2rem; margin-bottom: 2rem;"></p>
                <button class="start-btn" id="restartBtn">Back to Menu</button>
            </div>
        </div>
    </div>

    <script>
        // ===== STATE =====
        let selectedDrills = [];
        let totalQuestions = 10;
        let questionsLeft = 0;
        let correctCount = 0;
        let wrongCount = 0;
        let currentDrill = null;
        let num1, num2, correctAnswer;
        let waitingForContinue = false;
        let threeDigitQuestions = []; // Track which question numbers should be 3-digit
        let currentQuestionNumber = 0;
        
        // Timer mode state
        let isTimedMode = false;
        let timeLimitSeconds = 300;
        let elapsedSeconds = 0;
        let timerInterval = null;
        let timeExpired = false;
        let drillQueue = []; // For balanced random
        
        // Exponent drill state
        let currentInputType = 'single'; // 'single', 'twoBoxExp', 'twoBoxRange', 'multipleChoice'
        let correctBase, correctExp; // For two-box exponent answers
        let correctLow, correctHigh; // For range answers
        let correctChoice; // For multiple choice
        let mcChoices = []; // Array of {text, isCorrect}
        let currentQuestionType = ''; // Sub-type within a drill
        let currentExpRuleExplanation = ''; // Store explanation for MC
        let rootEstimationData = {}; // Store data for root estimation explanation
        
        // Stats state
        let statsExplanationData = {}; // Store data for stats explanations
        
        // Fraction state
        let correctNumerator, correctDenominator; // For fraction answers
        let fractionExplanationData = {}; // Store data for fraction explanations
        
        // Multi-select state
        let correctSelections = [];
        let userSelections = [];
        
        // Good numbers for factor drills
        const goodFactorNumbers = [12, 18, 24, 30, 36, 40, 42, 48, 54, 56, 60, 72, 80, 84, 90, 96];
        
        // Exponent/Root Tables data - organized by base for balanced selection
        const powersByBase = {
            2: [
                {base: 2, exp: 1, value: 2}, {base: 2, exp: 2, value: 4}, {base: 2, exp: 3, value: 8},
                {base: 2, exp: 4, value: 16}, {base: 2, exp: 5, value: 32}, {base: 2, exp: 6, value: 64},
                {base: 2, exp: 7, value: 128}, {base: 2, exp: 8, value: 256}, {base: 2, exp: 9, value: 512},
                {base: 2, exp: 10, value: 1024}
            ],
            3: [
                {base: 3, exp: 1, value: 3}, {base: 3, exp: 2, value: 9}, {base: 3, exp: 3, value: 27},
                {base: 3, exp: 4, value: 81}
            ],
            4: [
                {base: 4, exp: 1, value: 4}, {base: 4, exp: 2, value: 16}, {base: 4, exp: 3, value: 64},
                {base: 4, exp: 4, value: 256}, {base: 4, exp: 5, value: 1024}
            ],
            5: [
                {base: 5, exp: 1, value: 5}, {base: 5, exp: 2, value: 25}, {base: 5, exp: 3, value: 125},
                {base: 5, exp: 4, value: 625}
            ]
        };
        const expBases = [2, 3, 4, 5];
        
        // Perfect squares and cubes for estimation
        const perfectSquares = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169];
        const perfectCubes = [1, 8, 27, 64, 125];
        
        // Small primes for divisibility drills
        const smallPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];
        const notPrimeButLookLikeIt = [21, 27, 33, 39, 49, 51, 57, 63, 69, 77, 81, 87, 91, 93, 99];
        
        // ===== HELPER FUNCTIONS =====
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }
        
        function gcd(a, b) {
            while (b) { [a, b] = [b, a % b]; }
            return a;
        }
        
        function getFactors(n) {
            const factors = [];
            for (let i = 1; i <= Math.sqrt(n); i++) {
                if (n % i === 0) {
                    factors.push(i);
                    if (i !== n / i) factors.push(n / i);
                }
            }
            return factors.sort((a, b) => a - b);
        }
        
        function getPrimeFactorization(n) {
            const factors = {};
            let d = 2;
            while (n > 1) {
                while (n % d === 0) {
                    factors[d] = (factors[d] || 0) + 1;
                    n /= d;
                }
                d++;
            }
            return factors;
        }
        
        function formatPrimeFactorization(factors) {
            const parts = [];
            const primes = Object.keys(factors).map(Number).sort((a,b) => a-b);
            for (const p of primes) {
                if (factors[p] === 1) {
                    parts.push(p.toString());
                } else {
                    parts.push(p + '<sup>' + factors[p] + '</sup>');
                }
            }
            return parts.join(' × ');
        }
        
        function lcm(a, b) {
            return Math.abs(a * b) / gcd(a, b);
        }
        
        function reduceFraction(num, den) {
            const g = gcd(num, den);
            return [num / g, den / g];
        }
        
        function makeFractionHTML(num, den) {
            return `<span class="frac"><span class="frac-num">${num}</span><span class="frac-bar"></span><span class="frac-den">${den}</span></span>`;
        }
        
        function makeSolutionFractionHTML(num, den, isFinal = false) {
            const cls = isFinal ? 'sol-frac final' : 'sol-frac';
            return `<span class="${cls}"><span class="sol-num">${num}</span><span class="sol-bar"></span><span class="sol-den">${den}</span></span>`;
        }
        
        function makeCancelFractionHTML(num, den, newNum, newDen) {
            let numHTML, denHTML;
            if (newNum !== null && newNum !== num) {
                numHTML = `<span class="cancelled">${num}</span><span class="new-val">${newNum}</span>`;
            } else {
                numHTML = `${num}`;
            }
            if (newDen !== null && newDen !== den) {
                denHTML = `<span class="cancelled">${den}</span><span class="new-val">${newDen}</span>`;
            } else {
                denHTML = `${den}`;
            }
            return `<span class="sol-frac"><span class="sol-num">${numHTML}</span><span class="sol-bar"></span><span class="sol-den">${denHTML}</span></span>`;
        }
        
        // Stats helpers
        function generateNiceSet(count, minVal, maxVal, forMean) {
            if (forMean) {
                const nums = [];
                for (let i = 0; i < count - 1; i++) {
                    nums.push(Math.floor(Math.random() * (maxVal - minVal)) + minVal);
                }
                const currentSum = nums.reduce((a, b) => a + b, 0);
                const targetSum = Math.round(currentSum / count) * count;
                const lastNum = targetSum - currentSum;
                if (lastNum >= minVal && lastNum <= maxVal) {
                    nums.push(lastNum);
                } else {
                    nums.push(Math.floor(Math.random() * (maxVal - minVal)) + minVal);
                }
                return shuffleArray(nums);
            } else {
                const nums = [];
                for (let i = 0; i < count; i++) {
                    nums.push(Math.floor(Math.random() * (maxVal - minVal)) + minVal);
                }
                return nums;
            }
        }
        
        function calculateMean(arr) { return arr.reduce((a, b) => a + b, 0) / arr.length; }
        function calculateMedian(arr) {
            const sorted = [...arr].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
        }
        function calculateRange(arr) { return Math.max(...arr) - Math.min(...arr); }
        function calculateMode(arr) {
            const freq = {};
            arr.forEach(n => freq[n] = (freq[n] || 0) + 1);
            let maxFreq = 0, mode = null;
            for (const [num, count] of Object.entries(freq)) {
                if (count > maxFreq) { maxFreq = count; mode = parseInt(num); }
            }
            return mode;
        }
        function calculateStdDev(arr) {
            const mean = calculateMean(arr);
            const variance = arr.map(n => Math.pow(n - mean, 2)).reduce((a, b) => a + b, 0) / arr.length;
            return Math.sqrt(variance);
        }
        function formatNumber(n) {
            if (Number.isInteger(n)) return n.toString();
            return parseFloat(n.toFixed(2)).toString();
        }
        
        // ===== ELEMENTS =====
        const menuScreen = document.getElementById('menuScreen');
        const drillScreen = document.getElementById('drillScreen');
        const resultsScreen = document.getElementById('resultsScreen');
        const pageTitle = document.getElementById('pageTitle');
        const startBtn = document.getElementById('startBtn');
        const numQuestionsSelect = document.getElementById('numQuestions');
        const timeLimitSelect = document.getElementById('timeLimit');
        const drillOptions = document.querySelectorAll('.drill-option');
        const modeQuestionsBtn = document.getElementById('modeQuestions');
        const modeTimeBtn = document.getElementById('modeTime');
        const questionOptionsDiv = document.getElementById('questionOptions');
        const timeOptionsDiv = document.getElementById('timeOptions');
        const remainingStat = document.getElementById('remainingStat');
        const timerStat = document.getElementById('timerStat');
        const timerDisplay = document.getElementById('timerDisplay');
        
        const problemEl = document.getElementById('problem');
        const answerInput = document.getElementById('answerInput');
        const resultEl = document.getElementById('result');
        const solutionEl = document.getElementById('solution');
        const continueBtn = document.getElementById('continueBtn');
        const correctCountEl = document.getElementById('correctCount');
        const wrongCountEl = document.getElementById('wrongCount');
        const remainingEl = document.getElementById('remaining');
        const finalScoreEl = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        
        // ===== MODE TOGGLE =====
        modeQuestionsBtn.addEventListener('click', () => {
            isTimedMode = false;
            modeQuestionsBtn.classList.add('active');
            modeTimeBtn.classList.remove('active');
            questionOptionsDiv.style.display = 'flex';
            timeOptionsDiv.style.display = 'none';
        });
        
        modeTimeBtn.addEventListener('click', () => {
            isTimedMode = true;
            modeTimeBtn.classList.add('active');
            modeQuestionsBtn.classList.remove('active');
            timeOptionsDiv.style.display = 'flex';
            questionOptionsDiv.style.display = 'none';
        });
        
        // ===== MENU LOGIC =====
        drillOptions.forEach(option => {
            const checkbox = option.querySelector('input[type="checkbox"]');
            
            option.addEventListener('click', (e) => {
                if (e.target !== checkbox) {
                    checkbox.checked = !checkbox.checked;
                }
                option.classList.toggle('selected', checkbox.checked);
                updateSelectedDrills();
            });
            
            checkbox.addEventListener('change', () => {
                option.classList.toggle('selected', checkbox.checked);
                updateSelectedDrills();
            });
        });
        
        // Select All buttons
        document.querySelectorAll('.select-all-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Don't trigger collapse
                const section = btn.dataset.section;
                const sectionOptions = document.querySelector(`.drill-options[data-section="${section}"]`);
                const checkboxes = sectionOptions.querySelectorAll('input[type="checkbox"]');
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                
                checkboxes.forEach(cb => {
                    cb.checked = !allChecked;
                    cb.closest('.drill-option').classList.toggle('selected', !allChecked);
                });
                
                updateSelectedDrills();
            });
        });
        
        // Collapsible sections
        document.querySelectorAll('.section-header').forEach(header => {
            header.addEventListener('click', (e) => {
                // Don't collapse if clicking the Select All button
                if (e.target.classList.contains('select-all-btn')) return;
                
                const section = header.dataset.section;
                const options = document.querySelector(`.drill-options[data-section="${section}"]`);
                
                header.classList.toggle('collapsed');
                options.classList.toggle('collapsed');
            });
        });
        
        function updateSelectedDrills() {
            selectedDrills = [];
            drillOptions.forEach(option => {
                const checkbox = option.querySelector('input[type="checkbox"]');
                if (checkbox.checked) {
                    selectedDrills.push(checkbox.value);
                }
            });
            startBtn.disabled = selectedDrills.length === 0;
        }
        
        startBtn.addEventListener('click', startDrill);
        restartBtn.addEventListener('click', backToMenu);
        
        // New input elements
        const singleInputDiv = document.getElementById('singleInputDiv');
        const twoBoxExpDiv = document.getElementById('twoBoxExpDiv');
        const twoBoxRangeDiv = document.getElementById('twoBoxRangeDiv');
        const multipleChoiceDiv = document.getElementById('multipleChoiceDiv');
        const fractionInputDiv = document.getElementById('fractionInputDiv');
        const baseInput = document.getElementById('baseInput');
        const expInput = document.getElementById('expInput');
        const rangeLowInput = document.getElementById('rangeLowInput');
        const rangeHighInput = document.getElementById('rangeHighInput');
        const numeratorInput = document.getElementById('numeratorInput');
        const denominatorInput = document.getElementById('denominatorInput');
        const dataSetEl = document.getElementById('dataSet');
        const fractionProblemEl = document.getElementById('fractionProblem');
        const mcBtns = document.querySelectorAll('.mc-btn');
        
        // Multi-select and flashcard elements
        const multiSelectDiv = document.getElementById('multiSelectDiv');
        const msOptionsDiv = document.getElementById('msOptions');
        const msSubmitBtn = document.getElementById('msSubmitBtn');
        const flashcardDiv = document.getElementById('flashcardDiv');
        const revealBtn = document.getElementById('revealBtn');
        const flashcardAnswer = document.getElementById('flashcardAnswer');
        const selfGradeBtns = document.getElementById('selfGradeBtns');
        const gotItBtn = document.getElementById('gotItBtn');
        const missedItBtn = document.getElementById('missedItBtn');
        
        // Multiple choice event handlers
        mcBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if (waitingForContinue) return;
                const choice = btn.dataset.choice;
                checkMultipleChoice(choice);
            });
        });
        
        // Two-box input handlers
        baseInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                expInput.focus();
            }
        });
        
        expInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                checkTwoBoxExp();
            }
        });
        
        rangeLowInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                rangeHighInput.focus();
            }
        });
        
        rangeHighInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                checkTwoBoxRange();
            }
        });
        
        // Fraction input handlers
        numeratorInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                denominatorInput.focus();
            }
        });
        
        denominatorInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                checkFractionInput();
            }
        });
        
        // Multi-select handlers
        msSubmitBtn.addEventListener('click', () => {
            if (waitingForContinue) return;
            checkMultiSelect();
        });
        
        function buildMultiSelectButtons(options) {
            msOptionsDiv.innerHTML = '';
            userSelections = [];
            options.forEach(opt => {
                const btn = document.createElement('button');
                btn.className = 'ms-btn';
                btn.textContent = opt;
                btn.dataset.value = opt;
                btn.addEventListener('click', () => toggleMultiSelect(btn, opt));
                msOptionsDiv.appendChild(btn);
            });
        }
        
        function toggleMultiSelect(btn, value) {
            if (waitingForContinue) return;
            btn.classList.toggle('selected');
            if (btn.classList.contains('selected')) {
                userSelections.push(value);
            } else {
                userSelections = userSelections.filter(v => v !== value);
            }
        }
        
        function checkMultiSelect() {
            msSubmitBtn.disabled = true;
            
            const correctSet = new Set(correctSelections);
            const userSet = new Set(userSelections);
            
            let correctHits = 0;
            let wrongHits = 0;
            let missed = 0;
            
            const allBtns = msOptionsDiv.querySelectorAll('.ms-btn');
            allBtns.forEach(btn => {
                const val = parseInt(btn.dataset.value);
                const isCorrect = correctSet.has(val);
                const wasSelected = userSet.has(val);
                
                btn.disabled = true;
                
                if (isCorrect && wasSelected) {
                    btn.classList.add('correct');
                    correctHits++;
                } else if (isCorrect && !wasSelected) {
                    btn.classList.add('missed');
                    missed++;
                } else if (!isCorrect && wasSelected) {
                    btn.classList.add('wrong');
                    wrongHits++;
                }
            });
            
            const perfect = missed === 0 && wrongHits === 0;
            
            if (perfect) {
                correctCount++;
                correctCountEl.textContent = correctCount;
                resultEl.textContent = '✓ Perfect!';
                resultEl.className = 'result correct';
            } else if (wrongHits === 0 && missed > 0) {
                wrongCount++;
                wrongCountEl.textContent = wrongCount;
                resultEl.textContent = 'Missed ' + missed;
                resultEl.className = 'result partial';
            } else {
                wrongCount++;
                wrongCountEl.textContent = wrongCount;
                resultEl.textContent = '✗ ' + wrongHits + ' wrong, ' + missed + ' missed';
                resultEl.className = 'result wrong';
            }
            
            resultEl.style.display = 'block';
            solutionEl.innerHTML = '<div class="solution-inner"><div class="solution-line">Correct: <span class="answer-final">' + correctSelections.sort((a,b) => a-b).join(', ') + '</span></div></div>';
            
            continueBtn.style.display = 'inline-block';
            waitingForContinue = true;
        }
        
        // Flashcard handlers
        revealBtn.addEventListener('click', () => {
            revealBtn.style.display = 'none';
            flashcardAnswer.style.display = 'block';
            selfGradeBtns.style.display = 'flex';
        });
        
        gotItBtn.addEventListener('click', () => {
            correctCount++;
            correctCountEl.textContent = correctCount;
            goNext();
        });
        
        missedItBtn.addEventListener('click', () => {
            wrongCount++;
            wrongCountEl.textContent = wrongCount;
            goNext();
        });
        
        // Helper to show correct input type
        function showInputType(type) {
            currentInputType = type;
            singleInputDiv.style.display = type === 'single' ? 'block' : 'none';
            twoBoxExpDiv.style.display = type === 'twoBoxExp' ? 'block' : 'none';
            twoBoxRangeDiv.style.display = type === 'twoBoxRange' ? 'block' : 'none';
            multipleChoiceDiv.style.display = type === 'multipleChoice' ? 'block' : 'none';
            fractionInputDiv.style.display = type === 'fraction' ? 'block' : 'none';
            multiSelectDiv.style.display = type === 'multiSelect' ? 'block' : 'none';
            flashcardDiv.style.display = type === 'flashcard' ? 'block' : 'none';
            dataSetEl.style.display = 'none'; // Hide by default, show when needed
            fractionProblemEl.style.display = 'none'; // Hide by default, show when needed
            
            // Reset MC buttons visibility (show A-D, hide E by default)
            // Also clear text and reset state
            const allMcBtns = document.querySelectorAll('.mc-btn');
            allMcBtns.forEach((btn, i) => {
                btn.style.display = i < 4 ? 'flex' : 'none';
                btn.disabled = false;
                btn.classList.remove('selected', 'correct', 'wrong');
                // Clear the text content
                const textEl = btn.querySelector('.mc-text');
                if (textEl) textEl.textContent = '';
            });
            
            // Handle flashcard special case
            if (type === 'flashcard') {
                revealBtn.style.display = 'inline-block';
                flashcardAnswer.style.display = 'none';
                selfGradeBtns.style.display = 'none';
                solutionEl.style.display = 'none';
            } else {
                solutionEl.style.display = 'flex';
            }
            
            // Update hint text
            if (type === 'single') {
                solutionEl.innerHTML = '<span class="hint-text">Enter your answer above and press Enter.</span>';
            } else if (type === 'twoBoxExp') {
                solutionEl.innerHTML = '<span class="hint-text">Enter the base and exponent, then press Enter.</span>';
            } else if (type === 'twoBoxRange') {
                solutionEl.innerHTML = '<span class="hint-text">Enter the two integers it falls between.</span>';
            } else if (type === 'multipleChoice') {
                solutionEl.innerHTML = '<span class="hint-text">Click the correct answer.</span>';
            } else if (type === 'fraction') {
                solutionEl.innerHTML = '<span class="hint-text">Enter numerator and denominator, press Enter.</span>';
            } else if (type === 'multiSelect') {
                solutionEl.innerHTML = '<span class="hint-text">Select all that apply, then check.</span>';
            }
        }
        
        function showScreen(screen) {
            menuScreen.classList.remove('active');
            drillScreen.classList.remove('active');
            resultsScreen.classList.remove('active');
            screen.classList.add('active');
        }
        
        // Timer functions
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return mins + ':' + secs.toString().padStart(2, '0');
        }
        
        function startTimer() {
            elapsedSeconds = 0;
            timeExpired = false;
            timerDisplay.textContent = '0:00';
            timerInterval = setInterval(() => {
                elapsedSeconds++;
                timerDisplay.textContent = formatTime(elapsedSeconds);
                
                // Check if time limit reached
                if (elapsedSeconds >= timeLimitSeconds) {
                    timeExpired = true;
                    timerDisplay.style.color = '#fbbf24'; // Amber color to indicate time's up
                }
            }, 1000);
        }
        
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }
        
        // Build balanced drill queue
        function buildDrillQueue(count) {
            drillQueue = [];
            const numDrills = selectedDrills.length;
            
            // Create balanced distribution
            for (let i = 0; i < count; i++) {
                drillQueue.push(selectedDrills[i % numDrills]);
            }
            
            // Shuffle the queue
            for (let i = drillQueue.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [drillQueue[i], drillQueue[j]] = [drillQueue[j], drillQueue[i]];
            }
        }
        
        function startDrill() {
            correctCount = 0;
            wrongCount = 0;
            currentQuestionNumber = 0;
            
            if (isTimedMode) {
                // Time-based mode
                timeLimitSeconds = parseInt(timeLimitSelect.value);
                questionsLeft = 9999; // Effectively unlimited
                totalQuestions = 0; // Will count as we go
                
                // Show timer, hide remaining count
                remainingStat.style.display = 'none';
                timerStat.style.display = 'block';
                timerDisplay.style.color = '#fff'; // Reset color
                
                startTimer();
            } else {
                // Question-based mode
                totalQuestions = parseInt(numQuestionsSelect.value);
                questionsLeft = totalQuestions;
                
                // Show remaining count, hide timer
                remainingStat.style.display = 'block';
                timerStat.style.display = 'none';
                
                // Build balanced queue for multiple drills
                if (selectedDrills.length > 1) {
                    buildDrillQueue(totalQuestions);
                }
            }
            
            // For multiplication drills, decide which questions (max 2) should be 3-digit
            threeDigitQuestions = [];
            if (selectedDrills.includes('multiplication1x2') && !isTimedMode) {
                const max3Digit = Math.min(2, Math.floor(totalQuestions * 0.2));
                const num3Digit = Math.floor(Math.random() * (max3Digit + 1));
                
                const questionNumbers = Array.from({length: totalQuestions}, (_, i) => i);
                for (let i = 0; i < num3Digit; i++) {
                    const randomIndex = Math.floor(Math.random() * questionNumbers.length);
                    threeDigitQuestions.push(questionNumbers[randomIndex]);
                    questionNumbers.splice(randomIndex, 1);
                }
            }
            
            correctCountEl.textContent = '0';
            wrongCountEl.textContent = '0';
            remainingEl.textContent = questionsLeft;
            
            answerInput.style.display = '';
            showScreen(drillScreen);
            newProblem();
        }
        
        function backToMenu() {
            stopTimer();
            pageTitle.textContent = 'Fundamentals Drills';
            showScreen(menuScreen);
        }
        
        // ===== PROBLEM GENERATION =====
        function newProblem() {
            // Clear mcChoices BEFORE generators populate it
            mcChoices = [];
            // Pick drill: use queue if available (balanced), otherwise random
            if (drillQueue.length > 0) {
                currentDrill = drillQueue.shift();
            } else {
                currentDrill = selectedDrills[Math.floor(Math.random() * selectedDrills.length)];
            }
            
            if (currentDrill === 'addition') {
                num1 = Math.floor(Math.random() * 900) + 100;
                num2 = Math.floor(Math.random() * 900) + 100;
                correctAnswer = num1 + num2;
                problemEl.textContent = num1 + ' + ' + num2;
//                 pageTitle.textContent = 'Addition (Split & Stack)';
            } else if (currentDrill === 'subtraction') {
                // Ensure num1 > num2 for positive results (simpler for now)
                num1 = Math.floor(Math.random() * 400) + 500; // 500-899
                num2 = Math.floor(Math.random() * 400) + 100; // 100-499
                correctAnswer = num1 - num2;
                problemEl.textContent = num1 + ' − ' + num2;
//                 pageTitle.textContent = 'Subtraction (Split & Stack)';
            } else if (currentDrill === 'multiplication1x2') {
                num1 = Math.floor(Math.random() * 8) + 2; // 2-9
                // Check if this question should be 3-digit based on pre-determined list
                const shouldBe3Digit = threeDigitQuestions.includes(currentQuestionNumber);
                if (shouldBe3Digit) {
                    // 3-digit: exclude numbers ending in 00 (100, 200, 300, etc.)
                    do {
                        num2 = Math.floor(Math.random() * 900) + 100; // 100-999
                    } while (num2 % 100 === 0);
                } else {
                    // 2-digit: exclude numbers ending in 0 (20, 30, 40, etc.)
                    do {
                        num2 = Math.floor(Math.random() * 88) + 12; // 12-99
                    } while (num2 % 10 === 0);
                }
                correctAnswer = num1 * num2;
                problemEl.textContent = num1 + ' × ' + num2;
//                 pageTitle.textContent = 'Multiplication (Split & Distribute)';
            } else if (currentDrill === 'multiplication2x2') {
                // 2-digit × 2-digit, avoid multiples of 10, sum under 100
                // Cap num1 at 87 to ensure room for num2 to be at least 12
                do {
                    num1 = Math.floor(Math.random() * 76) + 12; // 12-87
                } while (num1 % 10 === 0);
                do {
                    // Cap num2 so sum stays under 100
                    const maxNum2 = Math.min(87, 99 - num1);
                    num2 = Math.floor(Math.random() * (maxNum2 - 11)) + 12; // 12 to maxNum2
                } while (num2 % 10 === 0);
                correctAnswer = num1 * num2;
                problemEl.textContent = num1 + ' × ' + num2;
//                 pageTitle.textContent = 'Multiplication (Split & Distribute FOIL)';
            } else if (currentDrill === 'division') {
                // Decide: single-digit divisor (70% chance) or 2-digit (30% chance)
                if (Math.random() < 0.7) {
                    // Single-digit divisor: 2-9, quotient 12-49
                    num2 = Math.floor(Math.random() * 8) + 2;
                    const quotient = Math.floor(Math.random() * 38) + 12;
                    num1 = num2 * quotient;
                    correctAnswer = quotient;
                } else {
                    // 2-digit divisor: 11-25, quotient must be 8, 9, 11, or 12
                    num2 = Math.floor(Math.random() * 15) + 11; // 11-25
                    const quotientOptions = [8, 9, 11, 12];
                    const quotient = quotientOptions[Math.floor(Math.random() * quotientOptions.length)];
                    num1 = num2 * quotient;
                    correctAnswer = quotient;
                }
                // Display as stacked fraction
                problemEl.innerHTML = '<div style="display: inline-flex; flex-direction: column; align-items: center; vertical-align: middle;"><span>' + num1 + '</span><span style="border-top: 2px solid white; padding-top: 0.2em; min-width: 2ch;">' + num2 + '</span></div>';
//                 pageTitle.textContent = 'Division (Split & Distribute)';
            } else if (currentDrill === 'rounding') {
                // GRE/GMAT style rounding questions
                // Places with test-standard language
                const placeData = [
                    { name: 'thousand', value: 1000 },
                    { name: 'hundred', value: 100 },
                    { name: 'ten', value: 10 },
                    { name: 'integer', value: 1 },
                    { name: 'tenth', value: 0.1 },
                    { name: 'hundredth', value: 0.01 },
                    { name: 'thousandth', value: 0.001 },
                    { name: 'ten-thousandth', value: 0.0001 }
                ];
                
                // Randomly decide the size/style of number
                const style = Math.random();
                let numValue, decimalPlaces;
                
                if (style < 0.25) {
                    // Small decimal: 0.XXXX to 9.XXXX
                    numValue = Math.random() * 10;
                    decimalPlaces = Math.floor(Math.random() * 3) + 2; // 2-4 decimal places
                } else if (style < 0.5) {
                    // Medium number: 10 to 999 with decimals
                    numValue = Math.random() * 990 + 10;
                    decimalPlaces = Math.floor(Math.random() * 4) + 1; // 1-4 decimal places
                } else if (style < 0.75) {
                    // Larger integer-ish: 100 to 9999, maybe with decimals
                    numValue = Math.random() * 9900 + 100;
                    decimalPlaces = Math.floor(Math.random() * 3); // 0-2 decimal places
                } else {
                    // Pure decimal focus: 0.0XXX to 0.9XXX
                    numValue = Math.random();
                    decimalPlaces = Math.floor(Math.random() * 2) + 3; // 3-4 decimal places
                }
                
                // Round to display precision
                const displayValue = parseFloat(numValue.toFixed(decimalPlaces));
                
                // Determine valid rounding places based on the number
                // Can't round to a place that doesn't have a digit to its right
                const intPartLength = Math.floor(displayValue).toString().length;
                
                // minIndex: leftmost place with a digit
                // For thousands(0): need intPart >= 1000
                // For hundreds(1): need intPart >= 100
                // For tens(2): need intPart >= 10
                // For integer(3): always valid if decimalPlaces > 0
                let minIndex = 3; // default to integer
                if (Math.floor(displayValue) >= 1000) minIndex = 0;
                else if (Math.floor(displayValue) >= 100) minIndex = 1;
                else if (Math.floor(displayValue) >= 10) minIndex = 2;
                else if (Math.floor(displayValue) >= 1) minIndex = 3;
                else minIndex = 4; // number is < 1, start at tenths
                
                // maxIndex: rightmost place we can round TO (need digit to the right)
                const maxIndex = 3 + decimalPlaces - 1; // 3 is integer position
                
                // Pick a random place to round to
                if (maxIndex < minIndex) minIndex = maxIndex; // edge case
                const roundToIndex = Math.floor(Math.random() * (maxIndex - minIndex + 1)) + minIndex;
                const roundToPlace = placeData[roundToIndex];
                
                // Build digit string for solution
                const fullStr = numValue.toFixed(4);
                const [intStr, decStr] = fullStr.split('.');
                const paddedInt = intStr.padStart(4, '0'); // 4 digits for up to thousands
                const allDigits = paddedInt + decStr; // positions 0-3 are int (thou,hun,ten,ones), 4-7 are decimal
                
                // Get the digit at the rounding place and the digit to its right
                const targetDigit = allDigits[roundToIndex];
                const rightDigit = allDigits[roundToIndex + 1];
                
                // Calculate the correct rounded answer
                // Use multiplication for decimal places to avoid floating-point errors
                if (roundToPlace.value >= 1) {
                    correctAnswer = Math.round(displayValue / roundToPlace.value) * roundToPlace.value;
                    correctAnswer = Math.round(correctAnswer);
                } else {
                    const multiplier = Math.round(1 / roundToPlace.value);
                    correctAnswer = Math.round(displayValue * multiplier) / multiplier;
                    const precision = Math.round(-Math.log10(roundToPlace.value));
                    correctAnswer = parseFloat(correctAnswer.toFixed(precision));
                }
                
                // Store for solution display
                window.roundingData = {
                    original: displayValue,
                    placeName: roundToPlace.name,
                    placeValue: roundToPlace.value,
                    targetDigit: targetDigit,
                    rightDigit: rightDigit,
                    decimalPlaces: decimalPlaces,
                    roundToIndex: roundToIndex
                };
                
                // Format the number for display
                let displayNum = displayValue.toFixed(decimalPlaces);
                if (decimalPlaces === 0) displayNum = String(Math.round(displayValue));
                
                // Randomly choose word form or decimal form (50/50)
                let placeDisplay;
                if (Math.random() < 0.5) {
                    // Word form
                    placeDisplay = roundToPlace.name;
                } else {
                    // Decimal form (but keep "integer" as word since "1" is confusing)
                    if (roundToPlace.value === 1) {
                        placeDisplay = 'integer';
                    } else if (roundToPlace.value >= 1) {
                        placeDisplay = roundToPlace.value.toLocaleString(); // adds commas: 1,000
                    } else {
                        placeDisplay = roundToPlace.value.toString(); // 0.1, 0.01, etc.
                    }
                }
                
                problemEl.innerHTML = 'Round <strong>' + displayNum + '</strong><br>to the nearest <strong>' + placeDisplay + '</strong>';
//                 pageTitle.textContent = 'Place Values & Rounding';
            } else if (currentDrill === 'tables') {
                // Pick a random type: basic tables, 15s, perfect squares, or zero variations
                const type = Math.random();
                let problemDisplay = '';
                
                if (type < 0.45) {
                    // Basic tables: 2-9, 11, 12 multiplication and division
                    const bases = [2, 3, 4, 5, 6, 7, 8, 9, 11, 12];
                    const base = bases[Math.floor(Math.random() * bases.length)];
                    const multiplier = Math.floor(Math.random() * 11) + 2; // 2-12
                    
                    if (Math.random() < 0.5) {
                        // Multiplication
                        num1 = base;
                        num2 = multiplier;
                        correctAnswer = num1 * num2;
                        problemDisplay = num1 + ' × ' + num2;
                        problemEl.textContent = problemDisplay;
                    } else {
                        // Division
                        num1 = base * multiplier;
                        num2 = base;
                        correctAnswer = multiplier;
                        problemDisplay = num1 + ' ÷ ' + num2;
                        problemEl.innerHTML = '<div style="display: inline-flex; flex-direction: column; align-items: center; vertical-align: middle;"><span>' + num1 + '</span><span style="border-top: 2px solid white; padding-top: 0.2em; min-width: 2ch;">' + num2 + '</span></div>';
                    }
                } else if (type < 0.55) {
                    // Small multiples of 15: 2×15 through 6×15
                    const multiplier = Math.floor(Math.random() * 5) + 2; // 2-6
                    
                    if (Math.random() < 0.5) {
                        // Multiplication
                        num1 = multiplier;
                        num2 = 15;
                        correctAnswer = num1 * num2;
                        problemDisplay = num1 + ' × ' + num2;
                        problemEl.textContent = problemDisplay;
                    } else {
                        // Division
                        num1 = multiplier * 15;
                        num2 = 15;
                        correctAnswer = multiplier;
                        problemDisplay = num1 + ' ÷ ' + num2;
                        problemEl.innerHTML = '<div style="display: inline-flex; flex-direction: column; align-items: center; vertical-align: middle;"><span>' + num1 + '</span><span style="border-top: 2px solid white; padding-top: 0.2em; min-width: 2ch;">' + num2 + '</span></div>';
                    }
                } else if (type < 0.75) {
                    // Perfect squares: 11-15 and 25
                    const squares = [11, 12, 13, 14, 15, 25];
                    const base = squares[Math.floor(Math.random() * squares.length)];
                    if (Math.random() < 0.5) {
                        // Square
                        num1 = base;
                        num2 = base;
                        correctAnswer = base * base;
                        problemDisplay = base + '²';
                        problemEl.textContent = problemDisplay;
                    } else {
                        // Square root (shown as division)
                        const square = base * base;
                        num1 = square;
                        num2 = base;
                        correctAnswer = base;
                        problemDisplay = square + ' ÷ ' + base;
                        problemEl.innerHTML = '<div style="display: inline-flex; flex-direction: column; align-items: center; vertical-align: middle;"><span>' + square + '</span><span style="border-top: 2px solid white; padding-top: 0.2em; min-width: 2ch;">' + base + '</span></div>';
                    }
                } else {
                    // Zero variations: 20×70, 200×7, 200×70, etc.
                    const bases = [2, 3, 4, 5, 6, 7, 8, 9];
                    const base1 = bases[Math.floor(Math.random() * bases.length)];
                    const base2 = bases[Math.floor(Math.random() * bases.length)];
                    
                    // Add 1-2 zeros to each
                    const zeros1 = Math.floor(Math.random() * 2) + 1; // 1-2
                    const zeros2 = Math.floor(Math.random() * 2) + 1; // 1-2
                    
                    num1 = base1 * Math.pow(10, zeros1);
                    num2 = base2 * Math.pow(10, zeros2);
                    
                    if (Math.random() < 0.5) {
                        // Multiplication
                        correctAnswer = num1 * num2;
                        problemDisplay = num1 + ' × ' + num2;
                        problemEl.textContent = problemDisplay;
                    } else {
                        // Division
                        const product = num1 * num2;
                        correctAnswer = num2;
                        problemDisplay = product + ' ÷ ' + num1;
                        problemEl.innerHTML = '<div style="display: inline-flex; flex-direction: column; align-items: center; vertical-align: middle;"><span>' + product + '</span><span style="border-top: 2px solid white; padding-top: 0.2em; min-width: 2ch;">' + num1 + '</span></div>';
                    }
                }
                // Store for solution display
                window.tablesProblemDisplay = problemDisplay;
//                 pageTitle.textContent = 'Multiplication Tables';
            } else if (currentDrill === 'estimateAdd') {
                // Estimation: Addition (Exchange)
                // Generate two numbers, find which is closer to a round number
                
                const sizes = [2, 3, 3, 3, 4]; // Weight toward 3-digit
                const size = sizes[Math.floor(Math.random() * sizes.length)];
                
                let scale, minVal, maxVal;
                if (size === 2) {
                    scale = 10;
                    minVal = 12; maxVal = 98;
                } else if (size === 3) {
                    scale = 100;
                    minVal = 105; maxVal = 895;
                } else {
                    scale = 1000;
                    minVal = 1050; maxVal = 8950;
                }
                
                // Generate two random numbers
                num1 = Math.floor(Math.random() * (maxVal - minVal)) + minVal;
                num2 = Math.floor(Math.random() * (maxVal - minVal)) + minVal;
                
                // Find distance to nearest round number for each
                const round1 = Math.round(num1 / scale) * scale;
                const round2 = Math.round(num2 / scale) * scale;
                const dist1 = Math.abs(num1 - round1);
                const dist2 = Math.abs(num2 - round2);
                
                // Pick the number closer to round as the one to make pretty
                // exchangeAmt is what pretty NEEDS: positive = needs more, negative = has extra
                let prettyIdx, prettyTarget, exchangeAmt;
                if (dist1 <= dist2) {
                    prettyIdx = 1; // num1 becomes pretty
                    prettyTarget = round1;
                    exchangeAmt = round1 - num1;
                } else {
                    prettyIdx = 2; // num2 becomes pretty
                    prettyTarget = round2;
                    exchangeAmt = round2 - num2;
                }
                
                correctAnswer = num1 + num2;
                
                // Store estimation data for solution
                window.estimateData = {
                    type: 'add',
                    num1: num1,
                    num2: num2,
                    prettyIdx: prettyIdx,
                    prettyTarget: prettyTarget,
                    exchangeAmt: exchangeAmt,
                    actual: correctAnswer
                };
                
                problemEl.textContent = num1 + ' + ' + num2;
//                 pageTitle.textContent = 'Estimation: Addition (Exchange)';
            } else if (currentDrill === 'estimateSub') {
                // Estimation: Subtraction (Slide)
                // Pick digit size: 2, 3, or 4 digits
                const sizes = [2, 3, 3, 3, 4]; // Weight toward 3-digit
                const size = sizes[Math.floor(Math.random() * sizes.length)];
                
                let target, lastDigits, prettyNum, slideAmount, slideDir;
                
                if (size === 2) {
                    // 2-digit subtracted number
                    const tens = Math.floor(Math.random() * 7) + 2; // 20-80 range
                    target = tens * 10;
                    lastDigits = Math.floor(Math.random() * 10); // 0-9
                    // Decide direction based on last digit
                    if (lastDigits >= 4 && lastDigits <= 6) {
                        // Middle - could go either way, pick randomly
                        slideDir = Math.random() < 0.5 ? 'up' : 'down';
                    } else if (lastDigits > 5) {
                        slideDir = 'up';
                    } else {
                        slideDir = 'down';
                    }
                    
                    if (slideDir === 'up') {
                        slideAmount = 10 - lastDigits;
                        prettyNum = target + 10;
                    } else {
                        slideAmount = -lastDigits;
                        prettyNum = target;
                    }
                    num2 = target + lastDigits;
                    // num1 must be bigger - add 20-80 to num2
                    num1 = num2 + Math.floor(Math.random() * 60) + 20;
                } else if (size === 3) {
                    // 3-digit subtracted number
                    const hundreds = Math.floor(Math.random() * 8) + 1; // 100-800 range
                    target = hundreds * 100;
                    lastDigits = Math.floor(Math.random() * 100); // 0-99
                    
                    if (lastDigits >= 45 && lastDigits <= 55) {
                        slideDir = 'both'; // Show both directions
                    } else if (lastDigits > 50) {
                        slideDir = 'up';
                    } else {
                        slideDir = 'down';
                    }
                    
                    if (slideDir === 'up' || slideDir === 'both') {
                        slideAmount = 100 - lastDigits;
                        prettyNum = target + 100;
                    } else {
                        slideAmount = -lastDigits;
                        prettyNum = target;
                    }
                    num2 = target + lastDigits;
                    // num1 must be bigger - add 100-500 to num2
                    num1 = num2 + Math.floor(Math.random() * 400) + 100;
                } else {
                    // 4-digit subtracted number
                    const thousands = Math.floor(Math.random() * 8) + 1; // 1000-8000 range
                    target = thousands * 1000;
                    lastDigits = Math.floor(Math.random() * 1000); // 0-999
                    
                    if (lastDigits >= 450 && lastDigits <= 550) {
                        slideDir = 'both';
                    } else if (lastDigits > 500) {
                        slideDir = 'up';
                    } else {
                        slideDir = 'down';
                    }
                    
                    if (slideDir === 'up' || slideDir === 'both') {
                        slideAmount = 1000 - lastDigits;
                        prettyNum = target + 1000;
                    } else {
                        slideAmount = -lastDigits;
                        prettyNum = target;
                    }
                    num2 = target + lastDigits;
                    // num1 must be bigger - add 500-3000 to num2
                    num1 = num2 + Math.floor(Math.random() * 2500) + 500;
                }
                
                correctAnswer = num1 - num2;
                
                // Store estimation data for solution
                window.estimateData = {
                    type: 'sub',
                    num1: num1,
                    num2: num2,
                    prettyTarget: prettyNum,
                    slideAmount: slideAmount,
                    slideDir: slideDir,
                    lastDigits: lastDigits,
                    actual: correctAnswer
                };
                
                problemEl.textContent = num1 + ' − ' + num2;
//                 pageTitle.textContent = 'Estimation: Subtraction (Slide)';
            } else if (currentDrill === 'expTables') {
                generateExpTables();
            } else if (currentDrill === 'expRules') {
                generateExpRules();
            } else if (currentDrill === 'rootEstimate') {
                generateRootEstimate();
            } else if (currentDrill === 'stats') {
                generateStats();
            } else if (currentDrill === 'divisibility') {
                generateDivisibility();
            } else if (currentDrill === 'fractions') {
                generateFractions();
            } else if (currentDrill === 'fracDec') {
                generateFracDec();
            } else if (currentDrill === 'fracDecPct') {
                generateFracDecPct();
            } else if (currentDrill === 'estimateMult') {
                generateEstimateMult();
            }
            
            if (!isTimedMode) {
                remainingEl.textContent = questionsLeft;
            }
            
            // Reset all inputs
            answerInput.value = '';
            baseInput.value = '';
            expInput.value = '';
            rangeLowInput.value = '';
            rangeHighInput.value = '';
            numeratorInput.value = '';
            denominatorInput.value = '';
            
            answerInput.disabled = false;
            baseInput.disabled = false;
            expInput.disabled = false;
            rangeLowInput.disabled = false;
            rangeHighInput.disabled = false;
            numeratorInput.disabled = false;
            denominatorInput.disabled = false;
            
            // Reset MC buttons
            mcBtns.forEach(btn => {
                btn.classList.remove('selected', 'correct', 'wrong');
                btn.disabled = false;
                btn.style.display = 'flex'; // Reset visibility
            });
            
            // mcChoices already cleared at top of newProblem
            
            // Reset multi-select
            userSelections = [];
            msSubmitBtn.disabled = false;
            
            resultEl.style.display = 'none';
            continueBtn.style.display = 'none';
            waitingForContinue = false;
            
            // Show appropriate input type and focus
            const customInputDrills = ['expTables', 'expRules', 'rootEstimate', 'stats', 'divisibility', 'fractions', 'fracDec', 'fracDecPct'];
            if (customInputDrills.includes(currentDrill)) {
                // Input type already set by generator
                if (currentInputType === 'single') {
                    answerInput.focus();
                } else if (currentInputType === 'twoBoxExp') {
                    baseInput.focus();
                } else if (currentInputType === 'twoBoxRange') {
                    rangeLowInput.focus();
                } else if (currentInputType === 'fraction') {
                    numeratorInput.focus();
                }
                // MC doesn't need focus
            } else {
                showInputType('single');
                solutionEl.innerHTML = '<span class="hint-text">Enter your answer above and press Enter.</span>';
                answerInput.focus();
            }
        }
        
        // ===== SPLIT NUMBER =====
        function splitNumber(n) {
            const str = Math.abs(n).toString();
            const parts = [];
            for (let i = 0; i < str.length; i++) {
                const digit = parseInt(str[i]);
                const place = Math.pow(10, str.length - 1 - i);
                parts.push(digit * place);
            }
            return parts;
        }
        
        // ===== SOLUTION BUILDERS =====
        function buildAdditionSolution() {
            const parts1 = splitNumber(num1);
            const parts2 = splitNumber(num2);
            
            while (parts1.length < parts2.length) parts1.unshift(0);
            while (parts2.length < parts1.length) parts2.unshift(0);
            
            const sums = parts1.map((p, i) => p + parts2[i]);
            
            let html = '<div class="solution-inner">';
            html += '<div class="solution-line">' + parts1.join(' + ') + '</div>';
            html += '<div class="solution-line">+ ' + parts2.join(' + ') + '</div>';
            html += '<div class="divider" style="width: ' + (parts1.join(' + ').length + 2) + 'ch"></div>';
            html += '<div class="solution-line">' + sums.join(' + ') + '</div>';
            
            let running = sums[0];
            for (let i = 1; i < sums.length; i++) {
                const nextVal = sums[i];
                running += nextVal;
                
                if (i < sums.length - 1) {
                    html += '<div class="solution-line">' + running + ' + ' + sums[i + 1] + '</div>';
                } else {
                    html += '<div class="solution-line answer-final">' + running + '</div>';
                }
            }
            
            html += '</div>';
            return html;
        }
        
        function buildSubtractionSolution() {
            const parts1 = splitNumber(num1);
            const parts2 = splitNumber(num2);
            
            while (parts1.length < parts2.length) parts1.unshift(0);
            while (parts2.length < parts1.length) parts2.unshift(0);
            
            // Calculate differences for each place value
            const diffs = parts1.map((p, i) => p - parts2[i]);
            
            // Format the first line: "500 + 10 + 8"
            let html = '<div class="solution-inner">';
            html += '<div class="solution-line">' + parts1.join(' + ') + '</div>';
            
            // Format the second line: "- 200 - 80 - 9"
            let line2 = '- ' + parts2[0];
            for (let i = 1; i < parts2.length; i++) {
                line2 += ' - ' + parts2[i];
            }
            html += '<div class="solution-line">' + line2 + '</div>';
            
            // Divider
            html += '<div class="divider" style="width: ' + (parts1.join(' + ').length + 2) + 'ch"></div>';
            
            // Format the difference line: "300 - 70 - 1" (showing + or - based on sign)
            let line3 = '';
            for (let i = 0; i < diffs.length; i++) {
                if (i === 0) {
                    line3 += diffs[i];
                } else {
                    if (diffs[i] >= 0) {
                        line3 += ' + ' + diffs[i];
                    } else {
                        line3 += ' - ' + Math.abs(diffs[i]);
                    }
                }
            }
            html += '<div class="solution-line">' + line3 + '</div>';
            
            // Cascade: combine left to right
            let running = diffs[0];
            for (let i = 1; i < diffs.length; i++) {
                const nextVal = diffs[i];
                running += nextVal;
                
                if (i < diffs.length - 1) {
                    // Show running total with next operation
                    const nextNext = diffs[i + 1];
                    if (nextNext >= 0) {
                        html += '<div class="solution-line">' + running + ' + ' + nextNext + '</div>';
                    } else {
                        html += '<div class="solution-line">' + running + ' - ' + Math.abs(nextNext) + '</div>';
                    }
                } else {
                    html += '<div class="solution-line answer-final">' + running + '</div>';
                }
            }
            
            html += '</div>';
            return html;
        }
        
        function buildMultiplication1x2Solution() {
            // num1 is the single digit multiplier (2-9)
            // num2 is the 2-3 digit multiplicand (12-999)
            
            // Split num2 into place values (e.g., 291 -> [200, 90, 1])
            const parts = splitNumber(num2);
            
            // Calculate products for each part
            const products = parts.map(p => num1 * p);
            
            // Find nearest round number above
            const str = num2.toString();
            const placeValue = Math.pow(10, str.length - 1);
            const firstDigit = parseInt(str[0]);
            
            // Calculate round number above and difference
            const roundAbove = (firstDigit + 1) * placeValue;
            const diffAbove = roundAbove - num2;
            
            // Filter out zeros from parts display (e.g., 40 should show as just "40", not "40 + 0")
            const partsFiltered = parts.filter(p => p !== 0);
            const productsFiltered = partsFiltered.map(p => num1 * p);
            
            // Determine if we should show the "exit above" (subtractive) path
            // For 2-digit: only if units digit is 7, 8, or 9
            // For 3-digit: only if within 10 of next hundred
            let showExitAbove = false;
            if (num2 >= 100) {
                // 3-digit: within 10 of next hundred
                showExitAbove = diffAbove <= 10 && diffAbove > 0;
            } else {
                // 2-digit: only if units digit is 7, 8, or 9
                const unitsDigit = num2 % 10;
                showExitAbove = (unitsDigit >= 7 && unitsDigit <= 9) && diffAbove > 0;
            }
            
            let html = '<div class="solution-inner">';
            
            // Show dual paths if subtractive path is viable, otherwise just show standard split
            if (showExitAbove) {
                // Show both paths side-by-side
                html += '<div style="display: flex; gap: 2rem; justify-content: center; align-items: flex-start;">';
                
                // Left side: Standard split
                html += '<div style="text-align: center; flex: 1;">';
                html += '<div class="solution-line">' + num1 + '(' + partsFiltered.join(' + ') + ')</div>';
                html += '<div style="height: 0.5rem"></div>';
                
                // Show distribution step: 4(200) + 4(90) + 4(8)
                const distStep = partsFiltered.map(p => num1 + '(' + p + ')').join(' + ');
                html += '<div class="solution-line">' + distStep + '</div>';
                html += '<div style="height: 0.5rem"></div>';
                
                html += '<div class="solution-line">' + productsFiltered.join(' + ') + '</div>';
                
                // Cascade for standard split
                let running = productsFiltered[0];
                for (let i = 1; i < productsFiltered.length; i++) {
                    running += productsFiltered[i];
                    if (i < productsFiltered.length - 1) {
                        html += '<div class="solution-line">' + running + ' + ' + productsFiltered[i + 1] + '</div>';
                    } else {
                        html += '<div class="solution-line answer-final">' + running + '</div>';
                    }
                }
                html += '</div>';
                
                html += '<div style="align-self: center; font-weight: bold; padding: 0 1rem;">OR</div>';
                
                // Right side: Exit path (subtractive)
                html += '<div style="text-align: center; flex: 1;">';
                html += '<div class="solution-line">' + num1 + '(' + roundAbove + ' - ' + diffAbove + ')</div>';
                html += '<div style="height: 0.5rem"></div>';
                html += '<div class="solution-line">' + num1 + '(' + roundAbove + ') - ' + num1 + '(' + diffAbove + ')</div>';
                html += '<div style="height: 0.5rem"></div>';
                html += '<div class="solution-line">' + (num1 * roundAbove) + ' - ' + (num1 * diffAbove) + '</div>';
                html += '<div class="solution-line answer-final">' + correctAnswer + '</div>';
                html += '</div>';
                
                html += '</div>';
                
            } else {
                // Only show standard split path
                html += '<div class="solution-line">' + num1 + '(' + partsFiltered.join(' + ') + ')</div>';
                html += '<div style="height: 0.5rem"></div>';
                
                // Show distribution step
                const distStep = partsFiltered.map(p => num1 + '(' + p + ')').join(' + ');
                html += '<div class="solution-line">' + distStep + '</div>';
                html += '<div style="height: 0.5rem"></div>';
                
                html += '<div class="solution-line">' + productsFiltered.join(' + ') + '</div>';
                
                // Cascade
                let running = productsFiltered[0];
                for (let i = 1; i < productsFiltered.length; i++) {
                    running += productsFiltered[i];
                    if (i < productsFiltered.length - 1) {
                        html += '<div class="solution-line">' + running + ' + ' + productsFiltered[i + 1] + '</div>';
                    } else {
                        html += '<div class="solution-line answer-final">' + running + '</div>';
                    }
                }
            }
            
            html += '</div>';
            return html;
        }

        function buildMultiplication2x2Solution() {
            // Check if either number is close to next 10 (within 2)
            const diff1 = 10 - (num1 % 10);
            const diff2 = 10 - (num2 % 10);
            const useExitAbove1 = diff1 <= 2 && diff1 > 0 && num1 % 10 !== 0;
            const useExitAbove2 = diff2 <= 2 && diff2 > 0 && num2 % 10 !== 0;
            
            // Decide which representation to use for each number
            const rep1 = useExitAbove1 
                ? { tens: Math.ceil(num1 / 10) * 10, units: -diff1 }
                : { tens: Math.floor(num1 / 10) * 10, units: num1 % 10 };
            
            const rep2 = useExitAbove2
                ? { tens: Math.ceil(num2 / 10) * 10, units: -diff2 }
                : { tens: Math.floor(num2 / 10) * 10, units: num2 % 10 };
            
            // Display strings for the split
            const display1 = useExitAbove1 
                ? '(' + rep1.tens + ' − ' + Math.abs(rep1.units) + ')'
                : '(' + rep1.tens + ' + ' + rep1.units + ')';
            const display2 = useExitAbove2
                ? '(' + rep2.tens + ' − ' + Math.abs(rep2.units) + ')'
                : '(' + rep2.tens + ' + ' + rep2.units + ')';
            
            // Inner display for row labels (without outer parens)
            const inner2 = useExitAbove2
                ? rep2.tens + ' − ' + Math.abs(rep2.units)
                : rep2.tens + ' + ' + rep2.units;
            
            // Calculate the four products
            const p1 = rep1.tens * rep2.tens;       // tens × tens (largest)
            const p2 = rep1.tens * rep2.units;      // tens × units
            const p3 = rep1.units * rep2.tens;      // units × tens
            const p4 = rep1.units * rep2.units;     // units × units (smallest)
            
            // Middle terms sum (p2 + p3 are the "like terms")
            const pMiddle = p2 + p3;
            
            // Format a number with sign for display (after first position)
            const withSign = (n) => n >= 0 ? '+ ' + n : '− ' + Math.abs(n);
            
            let html = '<div class="solution-inner" style="font-family: monospace;">';
            
            // First line: 31(64) = (30 + 1)(60 + 4)
            html += '<div class="solution-line">' + num1 + '(' + num2 + ') = ' + display1 + display2 + '</div>';
            html += '<div style="height: 0.75rem"></div>';
            
            // Build labels
            const label1 = rep1.tens + '(' + inner2 + ')→';
            const label2 = (rep1.units >= 0 ? rep1.units : '−' + Math.abs(rep1.units)) + '(' + inner2 + ')→';
            const maxLabelLen = Math.max(label1.length, label2.length);
            
            // Row 1: tens distribution - p1 and p2
            // Use grid for alignment
            html += '<div style="display: grid; grid-template-columns: auto auto auto auto; gap: 0 0.5rem; justify-content: start;">';
            html += '<div style="text-align: right; min-width: ' + maxLabelLen + 'ch;">' + label1 + '</div>';
            html += '<div style="text-align: right; min-width: 5ch;">' + p1 + '</div>';
            html += '<div style="text-align: right; min-width: 5ch;">' + withSign(p2) + '</div>';
            html += '<div style="min-width: 5ch;"></div>';
            html += '</div>';
            
            // Row 2: units distribution - p3 and p4 (p3 stacks under p2)
            html += '<div style="display: grid; grid-template-columns: auto auto auto auto; gap: 0 0.5rem; justify-content: start;">';
            html += '<div style="text-align: right; min-width: ' + maxLabelLen + 'ch;">' + label2 + '</div>';
            html += '<div style="min-width: 5ch;"></div>';
            html += '<div style="text-align: right; min-width: 5ch;">' + withSign(p3) + '</div>';
            html += '<div style="text-align: right; min-width: 5ch;">' + withSign(p4) + '</div>';
            html += '</div>';
            
            // Divider
            html += '<div class="divider" style="width: 100%; max-width: 20rem; margin: 0.5rem auto;"></div>';
            
            // Cascade using same grid structure for alignment
            // Line 1: p1 + pMiddle + p4
            html += '<div style="display: grid; grid-template-columns: auto auto auto auto; gap: 0 0.5rem; justify-content: start;">';
            html += '<div style="min-width: ' + maxLabelLen + 'ch;"></div>';
            html += '<div style="text-align: right; min-width: 5ch;">' + p1 + '</div>';
            html += '<div style="text-align: right; min-width: 5ch;">' + withSign(pMiddle) + '</div>';
            html += '<div style="text-align: right; min-width: 5ch;">' + withSign(p4) + '</div>';
            html += '</div>';
            
            // Line 2: (p1 + pMiddle) + p4
            const sum1 = p1 + pMiddle;
            html += '<div style="display: grid; grid-template-columns: auto auto auto auto; gap: 0 0.5rem; justify-content: start;">';
            html += '<div style="min-width: ' + maxLabelLen + 'ch;"></div>';
            html += '<div style="min-width: 5ch;"></div>';
            html += '<div style="text-align: right; min-width: 5ch;">' + sum1 + '</div>';
            html += '<div style="text-align: right; min-width: 5ch;">' + withSign(p4) + '</div>';
            html += '</div>';
            
            // Line 3: final answer (green)
            html += '<div style="display: grid; grid-template-columns: auto auto auto auto; gap: 0 0.5rem; justify-content: start;">';
            html += '<div style="min-width: ' + maxLabelLen + 'ch;"></div>';
            html += '<div style="min-width: 5ch;"></div>';
            html += '<div style="min-width: 5ch;"></div>';
            html += '<div class="answer-final" style="text-align: right; min-width: 5ch;">' + correctAnswer + '</div>';
            html += '</div>';
            
            html += '</div>';
            return html;
        }

        // Helper to build a stacked fraction
        function stackedFrac(num, denom) {
            return '<div style="display: inline-flex; flex-direction: column; align-items: center; vertical-align: middle; margin: 0 0.25rem;">' +
                   '<span>' + num + '</span>' +
                   '<span style="border-top: 1px solid rgba(255,255,255,0.7); padding-top: 0.1em; min-width: 1.5ch;">' + denom + '</span>' +
                   '</div>';
        }

        function buildDivisionSolution() {
            const dividend = num1;
            const divisor = num2;
            const quotient = correctAnswer;
            
            // Find lazy multiple: largest multiple of (divisor × 10) that fits
            const lazyBase = divisor * 10;
            const lazyMultiple = Math.floor(dividend / lazyBase) * lazyBase;
            const remainder = dividend - lazyMultiple;
            
            // Check for "exit above" path
            const nextLazyMultiple = lazyMultiple + lazyBase;
            const diffAbove = nextLazyMultiple - dividend;
            const showExitAbove = diffAbove <= 2 * divisor && diffAbove > 0;
            
            // If lazyMultiple is 0, the additive path isn't useful - only show exit above
            const skipAdditivePath = lazyMultiple === 0;
            
            // Generate multiples hint (show 3-4 relevant multiples)
            let multiples = [];
            for (let i = 1; i <= 5; i++) {
                const m = lazyBase * i;
                if (m <= dividend + lazyBase) {
                    multiples.push(m);
                }
            }
            if (multiples.length < 3) {
                multiples = [lazyBase, lazyBase * 2, lazyBase * 3];
            }
            
            // Helper for stacked fraction with custom width
            const stackFrac = (num, denom, minW) => {
                return '<div style="display: inline-flex; flex-direction: column; align-items: center; vertical-align: middle;">' +
                       '<span>' + num + '</span>' +
                       '<span style="border-top: 1px solid rgba(255,255,255,0.7); padding-top: 0.1em; min-width: ' + (minW || '1.5ch') + ';">' + denom + '</span>' +
                       '</div>';
            };
            
            let html = '<div class="solution-inner">';
            
            // Multiples hint line
            html += '<div class="solution-line" style="opacity: 0.8; font-size: 0.9em;">multiples of ' + divisor + '→ ' + multiples.join(', ') + '</div>';
            html += '<div style="height: 0.75rem"></div>';
            
            // Main layout: original fraction on left, solution on right
            html += '<div style="display: flex; align-items: flex-start; justify-content: center; gap: 1rem;">';
            
            // Left column: original fraction
            html += '<div style="display: flex; flex-direction: column; align-items: center;">';
            html += stackFrac(dividend, divisor, '2ch');
            html += '</div>';
            
            // Equals sign
            html += '<div style="padding-top: 0.5rem;">=</div>';
            
            if (showExitAbove && !skipAdditivePath) {
                // Two paths: additive and subtractive side by side
                html += '<div style="display: flex; align-items: flex-start; gap: 1rem;">';
                
                // Additive path
                html += '<div style="text-align: center;">';
                html += stackFrac(lazyMultiple + ' + ' + remainder, divisor, '6ch');
                html += '<div style="height: 0.5rem"></div>';
                html += '<div>' + stackFrac(lazyMultiple, divisor) + ' + ' + stackFrac(remainder, divisor) + '</div>';
                html += '<div style="height: 0.25rem"></div>';
                html += '<div>' + (lazyMultiple / divisor) + ' + ' + (remainder / divisor) + '</div>';
                html += '<div class="answer-final">' + quotient + '</div>';
                html += '</div>';
                
                html += '<div style="font-weight: bold; padding-top: 0.5rem;">OR</div>';
                
                // Subtractive path
                html += '<div style="text-align: center;">';
                html += stackFrac(nextLazyMultiple + ' − ' + diffAbove, divisor, '6ch');
                html += '<div style="height: 0.5rem"></div>';
                html += '<div>' + stackFrac(nextLazyMultiple, divisor) + ' − ' + stackFrac(diffAbove, divisor) + '</div>';
                html += '<div style="height: 0.25rem"></div>';
                html += '<div>' + (nextLazyMultiple / divisor) + ' − ' + (diffAbove / divisor) + '</div>';
                html += '<div class="answer-final">' + quotient + '</div>';
                html += '</div>';
                
                html += '</div>';
            } else if (showExitAbove && skipAdditivePath) {
                // Only exit above path
                html += '<div style="text-align: center;">';
                html += stackFrac(nextLazyMultiple + ' − ' + diffAbove, divisor, '6ch');
                html += '<div style="height: 0.5rem"></div>';
                html += '<div>' + stackFrac(nextLazyMultiple, divisor) + ' − ' + stackFrac(diffAbove, divisor) + '</div>';
                html += '<div style="height: 0.25rem"></div>';
                html += '<div>' + (nextLazyMultiple / divisor) + ' − ' + (diffAbove / divisor) + '</div>';
                html += '<div class="answer-final">' + quotient + '</div>';
                html += '</div>';
            } else {
                // Only additive path
                html += '<div style="text-align: center;">';
                html += stackFrac(lazyMultiple + ' + ' + remainder, divisor, '6ch');
                html += '<div style="height: 0.5rem"></div>';
                html += '<div>' + stackFrac(lazyMultiple, divisor) + ' + ' + stackFrac(remainder, divisor) + '</div>';
                html += '<div style="height: 0.25rem"></div>';
                html += '<div>' + (lazyMultiple / divisor) + ' + ' + (remainder / divisor) + '</div>';
                html += '<div class="answer-final">' + quotient + '</div>';
                html += '</div>';
            }
            
            html += '</div>'; // close main flex container
            
            html += '</div>';
            return html;
        }

        function buildRoundingSolution() {
            const data = window.roundingData;
            
            const targetDigit = data.targetDigit;
            const rightDigit = data.rightDigit;
            
            const roundsUp = parseInt(rightDigit) >= 5;
            const direction = roundsUp ? 'up' : 'down';
            const reason = roundsUp ? '≥ 5' : '< 5';
            
            // Build the highlighted number display
            // Format number with enough decimal places
            let numStr = data.original.toFixed(data.decimalPlaces);
            if (data.decimalPlaces === 0) numStr = String(Math.round(data.original));
            
            // Find position in display string
            // roundToIndex: 0=thousands, 1=hundreds, 2=tens, 3=ones, 4=tenths, etc.
            // We need to map this to position in the formatted string
            const intPart = Math.floor(data.original);
            const intLength = String(intPart).length;
            
            let highlightPos;
            if (data.roundToIndex <= 3) {
                // Integer part: position depends on how many integer digits there are
                // roundToIndex 3 = ones = last digit of integer part
                // roundToIndex 2 = tens = second to last, etc.
                highlightPos = intLength - (4 - data.roundToIndex);
            } else {
                // Decimal part: position is after decimal point
                // roundToIndex 4 = tenths = intLength + 1 (after decimal)
                // roundToIndex 5 = hundredths = intLength + 2, etc.
                highlightPos = intLength + 1 + (data.roundToIndex - 4);
            }
            
            // Build highlighted string
            let highlightedNum = '';
            for (let i = 0; i < numStr.length; i++) {
                if (i === highlightPos) {
                    highlightedNum += '<span style="color: #ffd700; text-decoration: underline; font-weight: bold;">' + numStr[i] + '</span>';
                } else {
                    highlightedNum += numStr[i];
                }
            }
            
            // Format the answer
            let displayAnswer;
            if (data.placeValue >= 1) {
                displayAnswer = String(correctAnswer);
            } else {
                const decPlaces = Math.round(-Math.log10(data.placeValue));
                displayAnswer = correctAnswer.toFixed(decPlaces);
            }
            
            let html = '<div class="solution-inner">';
            html += '<div class="solution-line">The <strong>' + data.placeName + '</strong> digit is ' + highlightedNum + '</div>';
            html += '<div class="solution-line">The digit to its right is <strong>' + rightDigit + '</strong></div>';
            html += '<div class="solution-line">Since ' + rightDigit + ' ' + reason + ', round <strong>' + direction + '</strong></div>';
            html += '<div class="solution-line answer-final">' + displayAnswer + '</div>';
            html += '</div>';
            return html;
        }
        
        function buildEstimateAddSolution() {
            const data = window.estimateData;
            let html = '<div class="solution-inner" style="text-align: center;">';
            
            const exchangeAmt = data.exchangeAmt; // positive = pretty needs it, negative = pretty gives it
            const absAmt = Math.abs(exchangeAmt);
            
            // Calculate adjusted values
            let adjusted1, adjusted2;
            if (data.prettyIdx === 1) {
                // num1 becomes pretty
                adjusted1 = data.prettyTarget;
                adjusted2 = data.num2 - exchangeAmt; // opposite direction
            } else {
                // num2 becomes pretty
                adjusted1 = data.num1 - exchangeAmt;
                adjusted2 = data.prettyTarget;
            }
            
            const estimate = adjusted1 + adjusted2;
            
            // Visual: arrow showing exchange
            // Arrow goes FROM donor TO recipient
            if (data.prettyIdx === 1) {
                // num1 needs it, num2 gives it
                if (exchangeAmt > 0) {
                    // num2 gives to num1
                    html += '<div class="solution-line" style="font-size: 1.3em; margin-bottom: 0.3em;">';
                    html += '<span style="opacity: 0.7;">' + data.num1 + '</span>';
                    html += ' <span style="color: #4ade80;">←' + absAmt + '─</span> ';
                    html += '<span style="opacity: 0.7;">' + data.num2 + '</span>';
                    html += '</div>';
                } else {
                    // num1 gives to num2
                    html += '<div class="solution-line" style="font-size: 1.3em; margin-bottom: 0.3em;">';
                    html += '<span style="opacity: 0.7;">' + data.num1 + '</span>';
                    html += ' <span style="color: #4ade80;">─' + absAmt + '→</span> ';
                    html += '<span style="opacity: 0.7;">' + data.num2 + '</span>';
                    html += '</div>';
                }
            } else {
                // num2 needs it, num1 gives it
                if (exchangeAmt > 0) {
                    // num1 gives to num2
                    html += '<div class="solution-line" style="font-size: 1.3em; margin-bottom: 0.3em;">';
                    html += '<span style="opacity: 0.7;">' + data.num1 + '</span>';
                    html += ' <span style="color: #4ade80;">─' + absAmt + '→</span> ';
                    html += '<span style="opacity: 0.7;">' + data.num2 + '</span>';
                    html += '</div>';
                } else {
                    // num2 gives to num1
                    html += '<div class="solution-line" style="font-size: 1.3em; margin-bottom: 0.3em;">';
                    html += '<span style="opacity: 0.7;">' + data.num1 + '</span>';
                    html += ' <span style="color: #4ade80;">←' + absAmt + '─</span> ';
                    html += '<span style="opacity: 0.7;">' + data.num2 + '</span>';
                    html += '</div>';
                }
            }
            
            // Show the simplified calculation
            html += '<div class="solution-line" style="font-size: 1.4em; color: #4ade80;">';
            html += adjusted1 + ' + ' + adjusted2 + ' = <strong>' + estimate + '</strong>';
            html += '</div>';
            
            html += '<div class="solution-line" style="margin-top: 0.5em; opacity: 0.7; font-size: 0.9em;">Actual: ' + data.actual + '</div>';
            html += '</div>';
            return html;
        }
        
        function buildEstimateSubSolution() {
            const data = window.estimateData;
            let html = '<div class="solution-inner" style="text-align: center;">';
            
            const showBoth = data.slideDir === 'both';
            
            // Primary direction
            let slideAmt = data.slideAmount;
            let prettyTarget = data.prettyTarget;
            let adjusted1 = data.num1 + slideAmt;
            let estimate = adjusted1 - prettyTarget;
            
            // Visual: original numbers with arrows underneath showing slide
            const slideSymbol = slideAmt > 0 ? '↑' : '↓';
            const absSlide = Math.abs(slideAmt);
            
            html += '<div class="solution-line" style="font-size: 1.3em; margin-bottom: 0.2em;">';
            html += '<span style="opacity: 0.7;">' + data.num1 + '</span>';
            html += ' − ';
            html += '<span style="opacity: 0.7;">' + data.num2 + '</span>';
            html += '</div>';
            
            // Arrows under both numbers
            html += '<div class="solution-line" style="color: #4ade80; font-size: 1.1em; margin-bottom: 0.3em;">';
            html += '<span>' + slideSymbol + absSlide + '</span>';
            html += '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';
            html += '<span>' + slideSymbol + absSlide + '</span>';
            html += '</div>';
            
            // The simplified calculation
            html += '<div class="solution-line" style="font-size: 1.4em; color: #4ade80;">';
            html += adjusted1 + ' − ' + prettyTarget + ' = <strong>' + estimate + '</strong>';
            html += '</div>';
            
            if (showBoth) {
                // Show alternate direction
                html += '<div class="solution-line" style="margin-top: 0.8em; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 0.6em; font-size: 0.9em; opacity: 0.8;"><em>Or slide the other way:</em></div>';
                
                const scale = data.num2 >= 1000 ? 1000 : (data.num2 >= 100 ? 100 : 10);
                const altPrettyNum = Math.floor(data.num2 / scale) * scale;
                const altSlideAmt = altPrettyNum - data.num2;
                const altAdjusted1 = data.num1 + altSlideAmt;
                const altEstimate = altAdjusted1 - altPrettyNum;
                const altSymbol = altSlideAmt > 0 ? '↑' : '↓';
                
                html += '<div class="solution-line" style="color: #4ade80;">';
                html += altAdjusted1 + ' − ' + altPrettyNum + ' = <strong>' + altEstimate + '</strong>';
                html += '</div>';
            }
            
            html += '<div class="solution-line" style="margin-top: 0.5em; opacity: 0.7; font-size: 0.9em;">Actual: ' + data.actual + '</div>';
            html += '</div>';
            return html;
        }
        
        // ===== ESTIMATION: MULTIPLICATION (BENCHMARK) =====
        let estimateMultData = {};
        
        function getEstimateScale(n) {
            if (n >= 1000) return 1000;
            if (n >= 100) return 100;
            return 10;
        }
        
        function generateEstimateMult() {
            showInputType('multipleChoice');
            
            // Explicitly show and enable all 5 MC buttons for this drill
            const allMcBtns = document.querySelectorAll('.mc-btn');
            allMcBtns.forEach(btn => {
                btn.style.display = 'flex';
                btn.disabled = false;
            });
            
            // Randomly pick 2x2 or 2x3
            const is2x3 = Math.random() < 0.5;
            
            let num1, num2;
            if (is2x3) {
                num1 = Math.floor(Math.random() * 70) + 20; // 20-89
                num2 = Math.floor(Math.random() * 700) + 200; // 200-899
            } else {
                num1 = Math.floor(Math.random() * 70) + 20; // 20-89
                num2 = Math.floor(Math.random() * 70) + 20; // 20-89
                while (Math.abs(num1 - num2) < 10) {
                    num2 = Math.floor(Math.random() * 70) + 20;
                }
            }
            
            // Ensure num2 is larger for display
            if (num1 > num2) {
                [num1, num2] = [num2, num1];
            }
            
            const actual = num1 * num2;
            const scale = getEstimateScale(num2);
            const lowerBench = Math.floor(num2 / scale) * scale;
            const upperBench = lowerBench + scale;
            const lowerProduct = num1 * lowerBench;
            const upperProduct = num1 * upperBench;
            
            // Generate 5 answer choices
            const choices = generateEstimateMultChoices(actual, lowerProduct, upperProduct, num1, num2, scale);
            shuffleArray(choices);
            
            const letters = ['A', 'B', 'C', 'D', 'E'];
            letters.forEach((letter, i) => {
                const el = document.getElementById('choice' + letter);
                if (el && choices[i]) {
                    el.textContent = formatNumber(choices[i].value);
                    el.parentElement.style.display = 'flex';
                }
            });
            
            // Find correct answer
            for (let i = 0; i < choices.length; i++) {
                if (choices[i].isCorrect) {
                    correctChoice = letters[i];
                    break;
                }
            }
            
            problemEl.innerHTML = formatNumber(num2) + ' × ' + num1 + ' ≈ ?';
            dataSetEl.style.display = 'none';
            fractionProblemEl.style.display = 'none';
            
            estimateMultData = {
                num1, num2, actual,
                lowerBench, upperBench,
                lowerProduct, upperProduct,
                scale
            };
            
//             pageTitle.textContent = 'Estimation: Multiplication';
        }
        
        function generateEstimateMultChoices(actual, lowerProduct, upperProduct, num1, num2, scale) {
            const choices = [];
            
            // Rounding scale based on magnitude
            let roundScale;
            if (actual >= 100000) roundScale = 10000;
            else if (actual >= 10000) roundScale = 1000;
            else if (actual >= 1000) roundScale = 100;
            else roundScale = 10;
            
            function roundChoice(n) {
                return Math.round(n / roundScale) * roundScale;
            }
            
            // Correct answer
            const correctValue = roundChoice(actual);
            choices.push({ value: correctValue, isCorrect: true });
            
            // Trap: round both down
            const roundedDown1 = Math.floor(num1 / 10) * 10;
            const roundedDown2 = Math.floor(num2 / scale) * scale;
            const trapLow = roundChoice(roundedDown1 * roundedDown2);
            if (trapLow !== correctValue && trapLow > 0) {
                choices.push({ value: trapLow, isCorrect: false });
            }
            
            // Trap: round both up
            const roundedUp1 = Math.ceil(num1 / 10) * 10;
            const roundedUp2 = Math.ceil(num2 / scale) * scale;
            const trapHigh = roundChoice(roundedUp1 * roundedUp2);
            if (trapHigh !== correctValue && !choices.find(c => c.value === trapHigh)) {
                choices.push({ value: trapHigh, isCorrect: false });
            }
            
            // Way too low
            const wayLow = roundChoice(lowerProduct * 0.7);
            if (wayLow > 0 && !choices.find(c => c.value === wayLow)) {
                choices.push({ value: wayLow, isCorrect: false });
            }
            
            // Way too high
            const wayHigh = roundChoice(upperProduct * 1.35);
            if (!choices.find(c => c.value === wayHigh)) {
                choices.push({ value: wayHigh, isCorrect: false });
            }
            
            // Fill remaining
            const spread = upperProduct - lowerProduct;
            let attempts = 0;
            while (choices.length < 5 && attempts < 20) {
                attempts++;
                let newVal;
                if (choices.length % 2 === 0) {
                    newVal = roundChoice(lowerProduct - spread * (0.2 + Math.random() * 0.4));
                } else {
                    newVal = roundChoice(upperProduct + spread * (0.2 + Math.random() * 0.4));
                }
                if (newVal > 0 && !choices.find(c => c.value === newVal)) {
                    choices.push({ value: newVal, isCorrect: false });
                }
            }
            
            // Last resort
            let offset = 1;
            while (choices.length < 5) {
                const below = roundChoice(correctValue - roundScale * offset * 3);
                const above = roundChoice(correctValue + roundScale * offset * 3);
                if (below > 0 && !choices.find(c => c.value === below)) {
                    choices.push({ value: below, isCorrect: false });
                } else if (!choices.find(c => c.value === above)) {
                    choices.push({ value: above, isCorrect: false });
                }
                offset++;
            }
            
            return choices.slice(0, 5);
        }
        
        function buildEstimateMultExplanation() {
            const d = estimateMultData;
            let html = '<div class="solution-inner">';
            html += '<div class="solution-line">Benchmark <span style="color: #fbbf24;">' + formatNumber(d.num2) + '</span>:</div>';
            html += '<div class="solution-line" style="color: #4ade80;">' + d.num1 + ' × ' + formatNumber(d.lowerBench) + ' = ' + formatNumber(d.lowerProduct) + '</div>';
            html += '<div class="solution-line" style="color: #4ade80;">' + d.num1 + ' × ' + formatNumber(d.upperBench) + ' = ' + formatNumber(d.upperProduct) + '</div>';
            html += '<div class="solution-line" style="margin-top: 0.5rem;">' + formatNumber(d.num2) + ' is between ' + formatNumber(d.lowerBench) + ' and ' + formatNumber(d.upperBench) + '</div>';
            html += '<div class="solution-line">→ Answer is between <span class="answer-final">' + formatNumber(d.lowerProduct) + '</span> and <span class="answer-final">' + formatNumber(d.upperProduct) + '</span></div>';
            html += '<div class="solution-line" style="margin-top: 0.5rem; opacity: 0.7; font-size: 0.9em;">Actual: ' + formatNumber(d.actual) + '</div>';
            html += '</div>';
            return html;
        }
        
        function buildStatsExplanation() {
            const d = statsExplanationData;
            let html = '<div class="solution-inner">';
            
            if (d.type === 'mean') {
                html += '<div class="solution-line">Sum: ' + d.sum + '</div>';
                html += '<div class="solution-line">' + d.sum + ' ÷ ' + d.count + ' = <span class="answer-final">' + formatNumber(d.answer) + '</span></div>';
            } else if (d.type === 'median') {
                html += '<div class="solution-line">Sorted: ' + d.sorted.join(', ') + '</div>';
                html += '<div class="solution-line">Middle value: <span class="answer-final">' + formatNumber(d.answer) + '</span></div>';
            } else if (d.type === 'range') {
                html += '<div class="solution-line">Max: ' + d.max + ', Min: ' + d.min + '</div>';
                html += '<div class="solution-line">' + d.max + ' − ' + d.min + ' = <span class="answer-final">' + d.answer + '</span></div>';
            } else if (d.type === 'mode') {
                const freqStr = Object.entries(d.freq).map(([n, c]) => n + ' appears ' + c + '×').join(', ');
                html += '<div class="solution-line" style="font-size: 0.9em;">' + freqStr + '</div>';
                html += '<div class="solution-line">Mode: <span class="answer-final">' + d.answer + '</span></div>';
            }
            
            html += '</div>';
            return html;
        }

        // ===== EXPONENT DRILL GENERATORS =====
        function generateExpTables() {
            // Pick random base first, then random power from that base
            const base = expBases[Math.floor(Math.random() * expBases.length)];
            const powers = powersByBase[base];
            const item = powers[Math.floor(Math.random() * powers.length)];
            
            // Three question types
            const types = ['valueFromPower', 'powerFromValue', 'rootFromValue'];
            currentQuestionType = types[Math.floor(Math.random() * types.length)];
            
            if (currentQuestionType === 'valueFromPower') {
                // Given 2^5, what's the value?
                problemEl.innerHTML = item.base + '<sup>' + item.exp + '</sup> = ?';
                correctAnswer = item.value;
                showInputType('single');
            } else if (currentQuestionType === 'powerFromValue') {
                // Given 32, express as base^exp
                problemEl.innerHTML = item.value + ' = ?<sup>?</sup>';
                correctBase = item.base;
                correctExp = item.exp;
                showInputType('twoBoxExp');
            } else {
                // Root question: Given √64 or ∛27, what's the value?
                if (item.exp === 2) {
                    problemEl.innerHTML = '√' + item.value + ' = ?';
                    correctAnswer = item.base;
                } else if (item.exp === 3) {
                    problemEl.innerHTML = '∛' + item.value + ' = ?';
                    correctAnswer = item.base;
                } else {
                    // For exp > 3, show as nth root
                    problemEl.innerHTML = '<sup>' + item.exp + '</sup>√' + item.value + ' = ?';
                    correctAnswer = item.base;
                }
                showInputType('single');
            }
            
//             pageTitle.textContent = 'Exp/Root Tables';
        }
        
        function generateExpRules() {
            // Five rule types
            const ruleType = Math.floor(Math.random() * 5);
            let base, exp1, exp2, correctText, wrongAnswers;
            
            if (ruleType === 0) {
                // Same base multiplication: x^a × x^b = x^(a+b)
                base = Math.floor(Math.random() * 4) + 2;
                exp1 = Math.floor(Math.random() * 4) + 2;
                exp2 = Math.floor(Math.random() * 4) + 2;
                problemEl.innerHTML = base + '<sup>' + exp1 + '</sup> × ' + base + '<sup>' + exp2 + '</sup> = ?';
                correctText = base + '<sup>' + (exp1 + exp2) + '</sup>';
                wrongAnswers = [
                    base + '<sup>' + (exp1 * exp2) + '</sup>',
                    (base * base) + '<sup>' + (exp1 + exp2) + '</sup>',
                    base + '<sup>' + Math.abs(exp1 - exp2) + '</sup>'
                ];
                
                const dots1 = Array(exp1).fill(base).join('·');
                const dots2 = Array(exp2).fill(base).join('·');
                currentExpRuleExplanation = '<div class="solution-line">Same base? Add the exponents!</div>' +
                    '<div class="solution-line">(' + dots1 + ')(' + dots2 + ')</div>' +
                    '<div class="solution-line">= ' + base + '<sup>' + exp1 + '+' + exp2 + '</sup> = ' + base + '<sup>' + (exp1 + exp2) + '</sup></div>';
                    
            } else if (ruleType === 1) {
                // Same base division: x^a ÷ x^b = x^(a-b)
                base = Math.floor(Math.random() * 4) + 2;
                
                // Sometimes top is bigger (positive result), sometimes bottom is bigger (negative result)
                if (Math.random() < 0.5) {
                    exp1 = Math.floor(Math.random() * 4) + 5; // 5-8 (bigger, on top)
                    exp2 = Math.floor(Math.random() * 3) + 2; // 2-4 (smaller, on bottom)
                } else {
                    exp1 = Math.floor(Math.random() * 3) + 2; // 2-4 (smaller, on top)
                    exp2 = Math.floor(Math.random() * 4) + 5; // 5-8 (bigger, on bottom)
                }
                
                const resultExp = exp1 - exp2;
                
                // Display as stacked fraction
                problemEl.innerHTML = '<div style="display: inline-flex; flex-direction: column; align-items: center; vertical-align: middle; font-size: 0.9em;">' +
                    '<span>' + base + '<sup>' + exp1 + '</sup></span>' +
                    '<span style="border-top: 2px solid white; padding-top: 0.2em; min-width: 2ch;">' + base + '<sup>' + exp2 + '</sup></span>' +
                    '</div> <span style="font-size: 2rem;">=</span> <span style="font-size: 2rem;">?</span>';
                
                // Correct answer - mix between negative exponent form and 1/x^n form
                if (resultExp < 0) {
                    if (Math.random() < 0.5) {
                        correctText = base + '<sup>' + resultExp + '</sup>';
                    } else {
                        correctText = '1/' + base + '<sup>' + Math.abs(resultExp) + '</sup>';
                    }
                } else {
                    correctText = base + '<sup>' + resultExp + '</sup>';
                }
                
                // Generate unique wrong answers
                const wrongSet = new Set();
                wrongSet.add(base + '<sup>' + (exp1 + exp2) + '</sup>');
                wrongSet.add(base + '<sup>' + (exp1 * exp2) + '</sup>');
                if (resultExp < 0) {
                    wrongSet.add(base + '<sup>' + Math.abs(resultExp) + '</sup>');
                    wrongSet.add('-' + base + '<sup>' + Math.abs(resultExp) + '</sup>');
                } else {
                    wrongSet.add(base + '<sup>' + (resultExp + 1) + '</sup>');
                    wrongSet.add(base + '<sup>' + (resultExp + 2) + '</sup>');
                }
                wrongSet.delete(correctText);
                wrongAnswers = Array.from(wrongSet).slice(0, 3);
                
                currentExpRuleExplanation = '<div class="solution-line">Same base? Subtract the exponents!</div>' +
                    '<div class="solution-line">' + base + '<sup>' + exp1 + '</sup> ÷ ' + base + '<sup>' + exp2 + '</sup></div>' +
                    '<div class="solution-line">= ' + base + '<sup>' + exp1 + '−' + exp2 + '</sup> = ' + base + '<sup>' + resultExp + '</sup>' + 
                    (resultExp < 0 ? ' = 1/' + base + '<sup>' + Math.abs(resultExp) + '</sup>' : '') + '</div>';
                
            } else if (ruleType === 2) {
                // Power to power: (x^a)^b = x^(a×b)
                base = Math.floor(Math.random() * 3) + 2;
                exp1 = Math.floor(Math.random() * 3) + 2;
                exp2 = Math.floor(Math.random() * 3) + 2;
                problemEl.innerHTML = '(' + base + '<sup>' + exp1 + '</sup>)<sup>' + exp2 + '</sup> = ?';
                correctText = base + '<sup>' + (exp1 * exp2) + '</sup>';
                wrongAnswers = [
                    base + '<sup>' + (exp1 + exp2) + '</sup>',
                    (base * exp2) + '<sup>' + exp1 + '</sup>',
                    base + '<sup>' + exp1 + '</sup><sup>' + exp2 + '</sup>'
                ];
                
                const repeated = Array(exp2).fill(base + '<sup>' + exp1 + '</sup>').join(' · ');
                currentExpRuleExplanation = '<div class="solution-line">Power to a power? Multiply the exponents!</div>' +
                    '<div class="solution-line">' + repeated + '</div>' +
                    '<div class="solution-line">= ' + base + '<sup>' + exp1 + '×' + exp2 + '</sup> = ' + base + '<sup>' + (exp1 * exp2) + '</sup></div>';
                    
            } else if (ruleType === 3) {
                // Zero exponent: x^0 = 1
                base = Math.floor(Math.random() * 8) + 2;
                problemEl.innerHTML = base + '<sup>0</sup> = ?';
                correctText = '1';
                wrongAnswers = ['0', base.toString(), 'undefined'];
                
                currentExpRuleExplanation = '<div class="solution-line">Any non-zero number to the power of 0 equals 1</div>' +
                    '<div class="solution-line">' + base + '<sup>0</sup> = 1</div>' +
                    '<div class="solution-line" style="font-size: 0.9em; opacity: 0.8;">(Think: ' + base + '<sup>1</sup> ÷ ' + base + '<sup>1</sup> = ' + base + '<sup>0</sup> = 1)</div>';
                    
            } else {
                // Negative exponent: x^(-n) = 1/x^n
                base = Math.floor(Math.random() * 4) + 2;
                exp1 = Math.floor(Math.random() * 3) + 1;
                const actualValue = Math.pow(base, exp1);
                problemEl.innerHTML = base + '<sup>-' + exp1 + '</sup> = ?';
                correctText = '1/' + actualValue;
                wrongAnswers = [
                    '-' + actualValue,
                    '-1/' + actualValue,
                    actualValue.toString()
                ];
                
                currentExpRuleExplanation = '<div class="solution-line">Negative exponent = reciprocal</div>' +
                    '<div class="solution-line">' + base + '<sup>-' + exp1 + '</sup> = 1/' + base + '<sup>' + exp1 + '</sup></div>' +
                    '<div class="solution-line">= 1/' + actualValue + '</div>';
            }
            
            // Setup multiple choice
            mcChoices = [{text: correctText, isCorrect: true}];
            wrongAnswers.forEach(w => mcChoices.push({text: w, isCorrect: false}));
            
            // Shuffle
            for (let i = mcChoices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [mcChoices[i], mcChoices[j]] = [mcChoices[j], mcChoices[i]];
            }
            
            // MUST call showInputType BEFORE populating buttons
            showInputType('multipleChoice');
            // Hide button E for this drill
            document.querySelectorAll('.mc-btn')[4].style.display = 'none';
            
            // Populate buttons
            const letters = ['A', 'B', 'C', 'D'];
            mcChoices.forEach((choice, i) => {
                document.getElementById('choice' + letters[i]).innerHTML = choice.text;
            });
            
//             pageTitle.textContent = 'Exponent Rules';
        }
        
        function generateRootEstimate() {
            // Square roots or cube roots between perfect squares/cubes
            const isSquare = Math.random() < 0.7;
            
            if (isSquare) {
                // Pick a number between perfect squares (not a perfect square itself)
                const idx = Math.floor(Math.random() * (perfectSquares.length - 1));
                const lower = perfectSquares[idx];
                const upper = perfectSquares[idx + 1];
                
                // Pick a number strictly between
                let num;
                do {
                    num = Math.floor(Math.random() * (upper - lower - 1)) + lower + 1;
                } while (num === lower || num === upper);
                
                problemEl.innerHTML = '√' + num + ' = ?';
                correctLow = Math.floor(Math.sqrt(lower));
                correctHigh = Math.floor(Math.sqrt(upper));
                
                rootEstimationData = {
                    type: 'square',
                    num: num,
                    lower: lower,
                    upper: upper,
                    rootLower: correctLow,
                    rootUpper: correctHigh
                };
            } else {
                // Cube roots
                const idx = Math.floor(Math.random() * (perfectCubes.length - 1));
                const lower = perfectCubes[idx];
                const upper = perfectCubes[idx + 1];
                
                let num;
                do {
                    num = Math.floor(Math.random() * (upper - lower - 1)) + lower + 1;
                } while (num === lower || num === upper);
                
                problemEl.innerHTML = '∛' + num + ' = ?';
                correctLow = Math.round(Math.pow(lower, 1/3));
                correctHigh = Math.round(Math.pow(upper, 1/3));
                
                rootEstimationData = {
                    type: 'cube',
                    num: num,
                    lower: lower,
                    upper: upper,
                    rootLower: correctLow,
                    rootUpper: correctHigh
                };
            }
            
            showInputType('twoBoxRange');
//             pageTitle.textContent = 'Root Estimation';
        }
        
        // ===== STATS GENERATORS =====
        function generateStats() {
            // Pick a random stats sub-type
            const types = ['mean', 'median', 'range', 'mode', 'stdDev'];
            const statsType = types[Math.floor(Math.random() * types.length)];
            
            if (statsType === 'mean') {
                showInputType('single');
                const nums = generateNiceSet(5, 5, 40, true);
                const mean = calculateMean(nums);
                problemEl.textContent = 'What is the mean (average)?';
                dataSetEl.textContent = nums.join(', ');
                dataSetEl.style.display = 'block';
                correctAnswer = mean;
                statsExplanationData = {
                    type: 'mean',
                    nums: nums,
                    sum: nums.reduce((a, b) => a + b, 0),
                    count: nums.length,
                    answer: mean
                };
            } else if (statsType === 'median') {
                showInputType('single');
                const nums = generateNiceSet(5, 3, 30, false);
                const median = calculateMedian(nums);
                problemEl.textContent = 'What is the median?';
                dataSetEl.textContent = nums.join(', ');
                dataSetEl.style.display = 'block';
                correctAnswer = median;
                statsExplanationData = {
                    type: 'median',
                    nums: nums,
                    sorted: [...nums].sort((a, b) => a - b),
                    answer: median
                };
            } else if (statsType === 'range') {
                showInputType('single');
                const nums = generateNiceSet(5, 5, 50, false);
                const range = calculateRange(nums);
                problemEl.textContent = 'What is the range?';
                dataSetEl.textContent = nums.join(', ');
                dataSetEl.style.display = 'block';
                correctAnswer = range;
                statsExplanationData = {
                    type: 'range',
                    nums: nums,
                    max: Math.max(...nums),
                    min: Math.min(...nums),
                    answer: range
                };
            } else if (statsType === 'mode') {
                showInputType('single');
                // Generate a set with a clear mode
                const baseNums = [];
                for (let i = 0; i < 3; i++) {
                    baseNums.push(Math.floor(Math.random() * 15) + 2);
                }
                const modeValue = baseNums[Math.floor(Math.random() * baseNums.length)];
                const repeatCount = Math.floor(Math.random() * 2) + 2;
                const nums = [...baseNums];
                for (let i = 1; i < repeatCount; i++) nums.push(modeValue);
                for (let i = 0; i < 2; i++) {
                    let newNum;
                    do { newNum = Math.floor(Math.random() * 15) + 2; }
                    while (nums.filter(n => n === newNum).length >= repeatCount);
                    nums.push(newNum);
                }
                shuffleArray(nums);
                problemEl.textContent = 'What is the mode?';
                dataSetEl.textContent = nums.join(', ');
                dataSetEl.style.display = 'block';
                correctAnswer = modeValue;
                const freq = {};
                nums.forEach(n => freq[n] = (freq[n] || 0) + 1);
                statsExplanationData = { type: 'mode', nums: nums, freq: freq, answer: modeValue };
            } else if (statsType === 'stdDev') {
                showInputType('multipleChoice');
                // Hide C, D, E - only 2 choices
                document.querySelectorAll('.mc-btn')[2].style.display = 'none';
                document.querySelectorAll('.mc-btn')[3].style.display = 'none';
                document.querySelectorAll('.mc-btn')[4].style.display = 'none';
                
                const center = Math.floor(Math.random() * 10) + 10;
                let setA, setB, higherSD, reason;
                if (Math.random() < 0.5) {
                    setA = [center, center, center, center, center];
                    const spread = Math.floor(Math.random() * 3) + 2;
                    setB = [center - 2*spread, center - spread, center, center + spread, center + 2*spread];
                    higherSD = 'B';
                    reason = 'Set A has no spread (all identical), Set B is spread out';
                } else {
                    const spread = Math.floor(Math.random() * 3) + 2;
                    setA = [center - 2*spread, center - spread, center, center + spread, center + 2*spread];
                    setB = [center-1, center, center, center+1, center];
                    higherSD = 'A';
                    reason = 'Set A has values farther from the mean';
                }
                
                problemEl.textContent = 'Which set has higher standard deviation?';
                dataSetEl.innerHTML = 'A = [' + setA.join(', ') + ']<br>B = [' + setB.join(', ') + ']';
                dataSetEl.style.display = 'block';
                
                document.getElementById('choiceA').textContent = 'Set A';
                document.getElementById('choiceB').textContent = 'Set B';
                correctChoice = higherSD;
                statsExplanationData = { type: 'stdDev', reason: reason };
            }
            
//             pageTitle.textContent = 'Descriptive Statistics';
        }
        
        // ===== DIVISIBILITY GENERATORS =====
        function generateDivisibility() {
            // Pick a random divisibility sub-type
            const types = ['spotPrime', 'terminology', 'divisibilityCheck', 'primeFactorizationMC', 'selectFactors', 'selectMultiples', 'findAllFactors', 'primeFactorizationFlash'];
            const divType = types[Math.floor(Math.random() * types.length)];
            
            if (divType === 'spotPrime') {
                showInputType('multipleChoice');
                // Hide button E - only 4 choices
                document.querySelectorAll('.mc-btn')[4].style.display = 'none';
                
                const primePool = smallPrimes.filter(p => p >= 10 && p <= 97);
                const prime = primePool[Math.floor(Math.random() * primePool.length)];
                
                const nonPrimes = [];
                const candidates = [];
                for (let i = prime - 10; i <= prime + 10; i++) {
                    if (i > 1 && !isPrime(i) && i !== prime) candidates.push(i);
                }
                shuffleArray(candidates);
                nonPrimes.push(...candidates.slice(0, 3));
                while (nonPrimes.length < 3) {
                    const fake = notPrimeButLookLikeIt[Math.floor(Math.random() * notPrimeButLookLikeIt.length)];
                    if (!nonPrimes.includes(fake)) nonPrimes.push(fake);
                }
                
                const allOptions = [prime, ...nonPrimes.slice(0, 3)];
                shuffleArray(allOptions);
                
                problemEl.textContent = 'Which is prime?';
                dataSetEl.style.display = 'none';
                correctChoice = ['A', 'B', 'C', 'D'][allOptions.indexOf(prime)];
                
                document.getElementById('choiceA').textContent = allOptions[0];
                document.getElementById('choiceB').textContent = allOptions[1];
                document.getElementById('choiceC').textContent = allOptions[2];
                document.getElementById('choiceD').textContent = allOptions[3];
                
                currentExpRuleExplanation = '<div class="solution-line">' + prime + ' is only divisible by 1 and itself</div>';
                
            } else if (divType === 'terminology') {
                showInputType('multipleChoice');
                // Hide C, D, E - only 2 choices
                document.querySelectorAll('.mc-btn')[2].style.display = 'none';
                document.querySelectorAll('.mc-btn')[3].style.display = 'none';
                document.querySelectorAll('.mc-btn')[4].style.display = 'none';
                
                const pairs = [[24, 4], [36, 6], [48, 8], [54, 9], [60, 12], [72, 8], [84, 7], [90, 15]];
                const [big, small] = pairs[Math.floor(Math.random() * pairs.length)];
                const multiplier = big / small;
                
                if (Math.random() < 0.5) {
                    problemEl.textContent = big + ' is ____ ' + small;
                    document.getElementById('choiceA').textContent = 'a multiple of';
                    document.getElementById('choiceB').textContent = 'a factor of';
                    correctChoice = 'A';
                    currentExpRuleExplanation = '<div class="solution-line">' + big + ' = ' + small + ' × ' + multiplier + '</div><div class="solution-line">' + big + ' is a multiple of ' + small + '</div>';
                } else {
                    problemEl.textContent = small + ' is ____ ' + big;
                    document.getElementById('choiceA').textContent = 'a factor of';
                    document.getElementById('choiceB').textContent = 'a multiple of';
                    correctChoice = 'A';
                    currentExpRuleExplanation = '<div class="solution-line">' + big + ' ÷ ' + small + ' = ' + multiplier + '</div><div class="solution-line">' + small + ' is a factor of ' + big + '</div>';
                }
                dataSetEl.style.display = 'none';
                
            } else if (divType === 'divisibilityCheck') {
                showInputType('multipleChoice');
                // Hide C, D, E - only 2 choices (True/False)
                document.querySelectorAll('.mc-btn')[2].style.display = 'none';
                document.querySelectorAll('.mc-btn')[3].style.display = 'none';
                document.querySelectorAll('.mc-btn')[4].style.display = 'none';
                
                const divisors = [3, 4, 5, 6, 8, 9];
                const divisor = divisors[Math.floor(Math.random() * divisors.length)];
                let num, isDivisible;
                
                if (Math.random() < 0.5) {
                    num = divisor * (Math.floor(Math.random() * 20) + 5);
                    isDivisible = true;
                } else {
                    do { num = Math.floor(Math.random() * 100) + 20; } while (num % divisor === 0);
                    isDivisible = false;
                }
                
                problemEl.textContent = num + ' is divisible by ' + divisor;
                dataSetEl.style.display = 'none';
                
                document.getElementById('choiceA').textContent = 'True';
                document.getElementById('choiceB').textContent = 'False';
                correctChoice = isDivisible ? 'A' : 'B';
                
                if (isDivisible) {
                    currentExpRuleExplanation = '<div class="solution-line">' + num + ' ÷ ' + divisor + ' = ' + (num/divisor) + '</div><div class="solution-line">Yes, it\'s divisible!</div>';
                } else {
                    currentExpRuleExplanation = '<div class="solution-line">' + num + ' ÷ ' + divisor + ' = ' + (num/divisor).toFixed(2) + '...</div><div class="solution-line">Not a whole number, so not divisible.</div>';
                }
                
            } else if (divType === 'primeFactorizationMC') {
                showInputType('multipleChoice');
                // Hide button E - only 4 choices
                document.querySelectorAll('.mc-btn')[4].style.display = 'none';
                
                const numbers = [36, 48, 54, 60, 72, 84, 90, 96, 100, 120, 144, 180];
                const num = numbers[Math.floor(Math.random() * numbers.length)];
                
                problemEl.textContent = 'Prime factorization of ' + num + '?';
                dataSetEl.style.display = 'none';
                
                const correctFactors = getPrimeFactorization(num);
                const correctText = formatPrimeFactorization(correctFactors);
                
                const wrongAnswers = [];
                const primes = Object.keys(correctFactors).map(Number);
                
                // Wrong 1: Change an exponent
                if (primes.length > 0) {
                    const wrongFactors1 = {...correctFactors};
                    const p = primes[Math.floor(Math.random() * primes.length)];
                    wrongFactors1[p] = correctFactors[p] + (Math.random() < 0.5 ? 1 : -1);
                    if (wrongFactors1[p] < 1) wrongFactors1[p] = correctFactors[p] + 1;
                    wrongAnswers.push(formatPrimeFactorization(wrongFactors1));
                }
                
                // Wrong 2: Add/remove a prime
                const wrongFactors2 = {...correctFactors};
                if (Math.random() < 0.5 && !wrongFactors2[7]) {
                    wrongFactors2[7] = 1;
                } else if (primes.length > 1) {
                    delete wrongFactors2[primes[primes.length - 1]];
                }
                wrongAnswers.push(formatPrimeFactorization(wrongFactors2));
                
                // Wrong 3: Use wrong base
                const wrongFactors3 = {...correctFactors};
                if (wrongFactors3[2]) {
                    wrongFactors3[4] = Math.floor(wrongFactors3[2] / 2);
                    delete wrongFactors3[2];
                } else {
                    const p = primes[0];
                    wrongFactors3[p] = correctFactors[p] * 2;
                }
                wrongAnswers.push(formatPrimeFactorization(wrongFactors3));
                
                const allOptions = [correctText, ...wrongAnswers.slice(0, 3)];
                const uniqueOptions = [...new Set(allOptions)];
                while (uniqueOptions.length < 4) uniqueOptions.push(num + ' × 1');
                shuffleArray(uniqueOptions);
                
                correctChoice = ['A', 'B', 'C', 'D'][uniqueOptions.indexOf(correctText)];
                
                document.getElementById('choiceA').innerHTML = uniqueOptions[0];
                document.getElementById('choiceB').innerHTML = uniqueOptions[1];
                document.getElementById('choiceC').innerHTML = uniqueOptions[2];
                document.getElementById('choiceD').innerHTML = uniqueOptions[3];
                
                currentExpRuleExplanation = '<div class="solution-line"><span class="answer-final">' + correctText + '</span></div>';
                
            } else if (divType === 'selectFactors') {
                showInputType('multiSelect');
                
                const num = goodFactorNumbers[Math.floor(Math.random() * goodFactorNumbers.length)];
                const factors = getFactors(num);
                
                problemEl.textContent = 'Select all factors of ' + num;
                dataSetEl.style.display = 'none';
                
                const nonFactors = [];
                for (let i = 2; i <= num / 2; i++) {
                    if (!factors.includes(i)) nonFactors.push(i);
                }
                shuffleArray(nonFactors);
                
                const middleFactors = factors.filter(f => f > 1 && f < num);
                const numFactorsToShow = Math.min(middleFactors.length, 5);
                const shownFactors = shuffleArray([...middleFactors]).slice(0, numFactorsToShow);
                const shownNonFactors = nonFactors.slice(0, Math.max(2, 6 - numFactorsToShow));
                
                const allOptions = [...shownFactors, ...shownNonFactors];
                shuffleArray(allOptions);
                
                correctSelections = shownFactors;
                buildMultiSelectButtons(allOptions);
                
            } else if (divType === 'selectMultiples') {
                showInputType('multiSelect');
                
                const base = [3, 4, 5, 6, 7, 8, 9][Math.floor(Math.random() * 7)];
                
                problemEl.textContent = 'Select all multiples of ' + base;
                dataSetEl.style.display = 'none';
                
                const multiples = [];
                const nonMultiples = [];
                const start = base * (Math.floor(Math.random() * 3) + 2);
                
                for (let i = start; i < start + base * 8; i++) {
                    if (i % base === 0) multiples.push(i);
                    else nonMultiples.push(i);
                }
                
                shuffleArray(multiples);
                shuffleArray(nonMultiples);
                
                const shownMultiples = multiples.slice(0, 4);
                const shownNonMultiples = nonMultiples.slice(0, 4);
                
                const allOptions = [...shownMultiples, ...shownNonMultiples];
                shuffleArray(allOptions);
                
                correctSelections = shownMultiples;
                buildMultiSelectButtons(allOptions);
                
            } else if (divType === 'findAllFactors') {
                showInputType('flashcard');
                
                const num = goodFactorNumbers[Math.floor(Math.random() * goodFactorNumbers.length)];
                const factors = getFactors(num);
                
                problemEl.textContent = 'Find ALL factors of ' + num;
                dataSetEl.style.display = 'none';
                
                let html = '<div style="text-align: center;">';
                html += '<div style="margin-bottom: 0.5rem; opacity: 0.8;">Factor pairs of ' + num + ':</div>';
                
                const pairs = [];
                for (let i = 0; i < Math.ceil(factors.length / 2); i++) {
                    const f1 = factors[i];
                    const f2 = factors[factors.length - 1 - i];
                    if (f1 <= f2) pairs.push(f1 + ' × ' + f2);
                }
                
                html += '<div style="margin-bottom: 0.75rem;">';
                pairs.forEach(p => { html += '<div>' + p + '</div>'; });
                html += '</div>';
                
                html += '<div class="answer-final">' + factors.join(', ') + '</div>';
                html += '<div style="margin-top: 0.5rem; opacity: 0.7; font-size: 0.9rem;">(' + factors.length + ' factors)</div>';
                html += '</div>';
                
                flashcardAnswer.innerHTML = html;
                
            } else if (divType === 'primeFactorizationFlash') {
                showInputType('flashcard');
                
                const numbers = [36, 48, 54, 60, 72, 84, 90, 96, 100, 120, 144, 180, 200, 225, 240, 360];
                const num = numbers[Math.floor(Math.random() * numbers.length)];
                
                problemEl.textContent = 'Prime factorization of ' + num;
                dataSetEl.style.display = 'none';
                
                const factors = getPrimeFactorization(num);
                
                let html = '<div style="text-align: center;">';
                html += '<div class="answer-final" style="font-size: 1.5rem;">' + formatPrimeFactorization(factors) + '</div>';
                html += '</div>';
                
                flashcardAnswer.innerHTML = html;
            }
            
//             pageTitle.textContent = 'Divisibility, Factors & Primes';
        }
        
        // ===== FRACTIONS GENERATORS =====
        function generateFractions() {
            // Pick a random fraction sub-type
            const types = ['reduce', 'equivalent', 'add', 'subtract', 'multiply', 'divide'];
            const fracType = types[Math.floor(Math.random() * types.length)];
            
            // Common fraction pools
            const reducedPairs = [
                [2, 3], [3, 4], [2, 5], [3, 5], [4, 5], [5, 6], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7],
                [3, 8], [5, 8], [7, 8], [2, 9], [4, 9], [5, 9], [7, 9], [8, 9], [1, 2], [1, 3], [1, 4],
                [1, 5], [1, 6], [1, 7], [1, 8], [1, 9], [7, 12], [5, 12], [11, 12], [7, 10], [9, 10]
            ];
            const operandFractions = [
                [1, 2], [1, 3], [2, 3], [1, 4], [3, 4], [1, 5], [2, 5], [3, 5], [4, 5],
                [1, 6], [5, 6], [1, 7], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7],
                [1, 8], [3, 8], [5, 8], [7, 8], [1, 9], [2, 9], [4, 9], [5, 9], [7, 9], [8, 9],
                [1, 10], [3, 10], [7, 10], [9, 10], [1, 12], [5, 12], [7, 12], [11, 12]
            ];
            
            if (fracType === 'reduce') {
                showInputType('fraction');
                const [num, den] = reducedPairs[Math.floor(Math.random() * reducedPairs.length)];
                const multipliers = [2, 3, 4, 5, 6, 7, 8, 9, 10, 12];
                const mult = multipliers[Math.floor(Math.random() * multipliers.length)];
                const bigNum = num * mult;
                const bigDen = den * mult;
                
                problemEl.textContent = 'Reduce to lowest terms:';
                fractionProblemEl.innerHTML = makeFractionHTML(bigNum, bigDen);
                
                correctNumerator = num;
                correctDenominator = den;
                fractionExplanationData = { type: 'reduce', bigNum, bigDen, num, den, mult };
                
            } else if (fracType === 'equivalent') {
                showInputType('single');
                const simpleFractions = [
                    [1, 2], [1, 3], [2, 3], [1, 4], [3, 4], [1, 5], [2, 5], [3, 5], [4, 5],
                    [1, 6], [5, 6], [2, 7], [3, 7], [1, 8], [3, 8], [5, 8], [7, 8]
                ];
                const [num, den] = simpleFractions[Math.floor(Math.random() * simpleFractions.length)];
                const multipliers = [2, 3, 4, 5, 6, 7, 8, 10, 12];
                const mult = multipliers[Math.floor(Math.random() * multipliers.length)];
                const newDen = den * mult;
                const newNum = num * mult;
                
                problemEl.textContent = 'Find the missing numerator:';
                fractionProblemEl.innerHTML = makeFractionHTML(num, den) + '<span class="op">=</span>' + makeFractionHTML('?', newDen);
                
                correctAnswer = newNum;
                fractionExplanationData = { type: 'equivalent', num, den, newNum, newDen, mult };
                
            } else if (fracType === 'add') {
                showInputType('fraction');
                let num1, den1, num2, den2;
                do {
                    [num1, den1] = operandFractions[Math.floor(Math.random() * operandFractions.length)];
                    [num2, den2] = operandFractions[Math.floor(Math.random() * operandFractions.length)];
                } while (den1 === den2 || den1 % den2 === 0 || den2 % den1 === 0);
                
                const commonDen = lcm(den1, den2);
                const resultNum = num1 * (commonDen / den1) + num2 * (commonDen / den2);
                const [reducedNum, reducedDen] = reduceFraction(resultNum, commonDen);
                
                problemEl.textContent = 'Add and reduce:';
                fractionProblemEl.innerHTML = makeFractionHTML(num1, den1) + '<span class="op">+</span>' + makeFractionHTML(num2, den2);
                
                correctNumerator = reducedNum;
                correctDenominator = reducedDen;
                fractionExplanationData = { type: 'add', num1, den1, num2, den2, commonDen, resultNum, reducedNum, reducedDen };
                
            } else if (fracType === 'subtract') {
                showInputType('fraction');
                let num1, den1, num2, den2;
                do {
                    [num1, den1] = operandFractions[Math.floor(Math.random() * operandFractions.length)];
                    [num2, den2] = operandFractions[Math.floor(Math.random() * operandFractions.length)];
                } while (den1 === den2 || den1 % den2 === 0 || den2 % den1 === 0);
                
                const commonDen = lcm(den1, den2);
                let resultNum = num1 * (commonDen / den1) - num2 * (commonDen / den2);
                if (resultNum <= 0) {
                    [num1, den1, num2, den2] = [num2, den2, num1, den1];
                    resultNum = num1 * (commonDen / den1) - num2 * (commonDen / den2);
                }
                const [reducedNum, reducedDen] = reduceFraction(resultNum, commonDen);
                
                problemEl.textContent = 'Subtract and reduce:';
                fractionProblemEl.innerHTML = makeFractionHTML(num1, den1) + '<span class="op">−</span>' + makeFractionHTML(num2, den2);
                
                correctNumerator = reducedNum;
                correctDenominator = reducedDen;
                fractionExplanationData = { type: 'subtract', num1, den1, num2, den2, commonDen, resultNum, reducedNum, reducedDen };
                
            } else if (fracType === 'multiply') {
                showInputType('fraction');
                const multFractions = [
                    [1, 2], [1, 3], [1, 4], [2, 3], [3, 4], [2, 5], [3, 5], [4, 5],
                    [5, 6], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7],
                    [3, 8], [5, 8], [7, 8], [2, 9], [4, 9], [5, 9], [7, 9], [8, 9]
                ];
                const [num1, den1] = multFractions[Math.floor(Math.random() * multFractions.length)];
                const [num2, den2] = multFractions[Math.floor(Math.random() * multFractions.length)];
                
                const cancel1 = gcd(num1, den2);
                const cancel2 = gcd(num2, den1);
                const afterCancel_num1 = num1 / cancel1;
                const afterCancel_den2 = den2 / cancel1;
                const afterCancel_num2 = num2 / cancel2;
                const afterCancel_den1 = den1 / cancel2;
                
                const resultNum = afterCancel_num1 * afterCancel_num2;
                const resultDen = afterCancel_den1 * afterCancel_den2;
                const [reducedNum, reducedDen] = reduceFraction(resultNum, resultDen);
                
                problemEl.textContent = 'Multiply and reduce:';
                fractionProblemEl.innerHTML = makeFractionHTML(num1, den1) + '<span class="op">×</span>' + makeFractionHTML(num2, den2);
                
                correctNumerator = reducedNum;
                correctDenominator = reducedDen;
                fractionExplanationData = {
                    type: 'multiply', num1, den1, num2, den2, cancel1, cancel2,
                    afterCancel_num1, afterCancel_den1, afterCancel_num2, afterCancel_den2,
                    resultNum, resultDen, reducedNum, reducedDen
                };
                
            } else if (fracType === 'divide') {
                showInputType('fraction');
                const divFractions = [
                    [1, 2], [1, 3], [1, 4], [2, 3], [3, 4], [2, 5], [3, 5], [4, 5],
                    [5, 6], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7],
                    [3, 8], [5, 8], [7, 8], [2, 9], [4, 9], [5, 9], [7, 9], [8, 9]
                ];
                const [num1, den1] = divFractions[Math.floor(Math.random() * divFractions.length)];
                const [num2, den2] = divFractions[Math.floor(Math.random() * divFractions.length)];
                
                // Same-Change-Flip: num1/den1 × den2/num2
                const cancel1 = gcd(num1, num2);
                const cancel2 = gcd(den2, den1);
                const afterCancel_num1 = num1 / cancel1;
                const afterCancel_num2 = num2 / cancel1;
                const afterCancel_den2 = den2 / cancel2;
                const afterCancel_den1 = den1 / cancel2;
                
                const resultNum = afterCancel_num1 * afterCancel_den2;
                const resultDen = afterCancel_den1 * afterCancel_num2;
                const [reducedNum, reducedDen] = reduceFraction(resultNum, resultDen);
                
                problemEl.textContent = 'Divide and reduce:';
                fractionProblemEl.innerHTML = makeFractionHTML(num1, den1) + '<span class="op">÷</span>' + makeFractionHTML(num2, den2);
                
                correctNumerator = reducedNum;
                correctDenominator = reducedDen;
                fractionExplanationData = {
                    type: 'divide', num1, den1, num2, den2, cancel1, cancel2,
                    afterCancel_num1, afterCancel_den1, afterCancel_num2, afterCancel_den2,
                    resultNum, resultDen, reducedNum, reducedDen
                };
            }
            
            // Show fraction problem display AFTER showInputType has been called
            fractionProblemEl.style.display = 'flex';
            
//             pageTitle.textContent = 'Fraction Mechanics';
        }
        
        function buildFractionExplanation() {
            const d = fractionExplanationData;
            let html = '<div class="solution-inner">';
            
            if (d.type === 'reduce') {
                html += `<div class="solution-line solution-fractions">`;
                html += makeSolutionFractionHTML(d.bigNum, d.bigDen);
                html += `<span class="solution-op">→</span>`;
                html += `<span class="divide-by">÷${d.mult}</span>`;
                html += `<span class="solution-op">→</span>`;
                html += makeSolutionFractionHTML(d.num, d.den, true);
                html += `</div>`;
            } else if (d.type === 'equivalent') {
                html += `<div class="solution-line solution-fractions">`;
                html += makeSolutionFractionHTML(d.num, d.den);
                html += `<span class="solution-op">→</span>`;
                html += `<span class="multiply-by">×${d.mult}</span>`;
                html += `<span class="solution-op">→</span>`;
                html += makeSolutionFractionHTML(d.newNum, d.newDen, true);
                html += `</div>`;
            } else if (d.type === 'add') {
                const mult1 = d.commonDen / d.den1;
                const mult2 = d.commonDen / d.den2;
                const conv1 = d.num1 * mult1;
                const conv2 = d.num2 * mult2;
                html += `<div class="solution-line solution-fractions">`;
                html += `<span class="sol-frac"><span class="sol-num">${d.num1}(${mult1})</span><span class="sol-bar"></span><span class="sol-den">${d.den1}(${mult1})</span></span>`;
                html += `<span class="solution-op">+</span>`;
                html += `<span class="sol-frac"><span class="sol-num">${d.num2}(${mult2})</span><span class="sol-bar"></span><span class="sol-den">${d.den2}(${mult2})</span></span>`;
                html += `</div>`;
                html += `<div class="solution-line solution-fractions">`;
                html += makeSolutionFractionHTML(conv1, d.commonDen);
                html += `<span class="solution-op">+</span>`;
                html += makeSolutionFractionHTML(conv2, d.commonDen);
                html += `<span class="solution-op">=</span>`;
                if (d.resultNum !== d.reducedNum || d.commonDen !== d.reducedDen) {
                    html += makeSolutionFractionHTML(d.resultNum, d.commonDen);
                    html += `<span class="solution-op">=</span>`;
                }
                html += makeSolutionFractionHTML(d.reducedNum, d.reducedDen, true);
                html += `</div>`;
            } else if (d.type === 'subtract') {
                const mult1 = d.commonDen / d.den1;
                const mult2 = d.commonDen / d.den2;
                const conv1 = d.num1 * mult1;
                const conv2 = d.num2 * mult2;
                html += `<div class="solution-line solution-fractions">`;
                html += `<span class="sol-frac"><span class="sol-num">${d.num1}(${mult1})</span><span class="sol-bar"></span><span class="sol-den">${d.den1}(${mult1})</span></span>`;
                html += `<span class="solution-op">−</span>`;
                html += `<span class="sol-frac"><span class="sol-num">${d.num2}(${mult2})</span><span class="sol-bar"></span><span class="sol-den">${d.den2}(${mult2})</span></span>`;
                html += `</div>`;
                html += `<div class="solution-line solution-fractions">`;
                html += makeSolutionFractionHTML(conv1, d.commonDen);
                html += `<span class="solution-op">−</span>`;
                html += makeSolutionFractionHTML(conv2, d.commonDen);
                html += `<span class="solution-op">=</span>`;
                if (d.resultNum !== d.reducedNum || d.commonDen !== d.reducedDen) {
                    html += makeSolutionFractionHTML(d.resultNum, d.commonDen);
                    html += `<span class="solution-op">=</span>`;
                }
                html += makeSolutionFractionHTML(d.reducedNum, d.reducedDen, true);
                html += `</div>`;
            } else if (d.type === 'multiply') {
                const hasCancellation = d.cancel1 > 1 || d.cancel2 > 1;
                html += `<div class="solution-line solution-fractions">`;
                if (hasCancellation) {
                    html += makeCancelFractionHTML(d.num1, d.den1, d.cancel1 > 1 ? d.afterCancel_num1 : null, d.cancel2 > 1 ? d.afterCancel_den1 : null);
                    html += `<span class="solution-op">×</span>`;
                    html += makeCancelFractionHTML(d.num2, d.den2, d.cancel2 > 1 ? d.afterCancel_num2 : null, d.cancel1 > 1 ? d.afterCancel_den2 : null);
                } else {
                    html += makeSolutionFractionHTML(d.num1, d.den1);
                    html += `<span class="solution-op">×</span>`;
                    html += makeSolutionFractionHTML(d.num2, d.den2);
                }
                html += `<span class="solution-op">=</span>`;
                html += makeSolutionFractionHTML(d.reducedNum, d.reducedDen, true);
                html += `</div>`;
            } else if (d.type === 'divide') {
                html += `<div class="solution-line" style="font-size: 0.9em; margin-bottom: 0.5rem;">Same-Change-Flip:</div>`;
                const hasCancellation = d.cancel1 > 1 || d.cancel2 > 1;
                html += `<div class="solution-line solution-fractions">`;
                if (hasCancellation) {
                    html += makeCancelFractionHTML(d.num1, d.den1, d.cancel1 > 1 ? d.afterCancel_num1 : null, d.cancel2 > 1 ? d.afterCancel_den1 : null);
                    html += `<span class="solution-op">×</span>`;
                    html += makeCancelFractionHTML(d.den2, d.num2, d.cancel2 > 1 ? d.afterCancel_den2 : null, d.cancel1 > 1 ? d.afterCancel_num2 : null);
                } else {
                    html += makeSolutionFractionHTML(d.num1, d.den1);
                    html += `<span class="solution-op">×</span>`;
                    html += makeSolutionFractionHTML(d.den2, d.num2);
                }
                html += `<span class="solution-op">=</span>`;
                html += makeSolutionFractionHTML(d.reducedNum, d.reducedDen, true);
                html += `</div>`;
            }
            
            html += '</div>';
            return html;
        }
        
        // ===== FRACTION/DECIMAL/PERCENT CONVERSION =====
        // Benchmark conversions - denominators: 2, 3, 4, 5, 8, 9, 10, 100, 1000
        // For repeating decimals, repDigits shows what repeats (displayed with overline)
        const benchmarkConversions = [
            // halves
            { num: 1, den: 2, dec: 0.5, pct: 50 },
            { num: 3, den: 2, dec: 1.5, pct: 150 },
            { num: 5, den: 2, dec: 2.5, pct: 250 },
            // thirds (repeating)
            { num: 1, den: 3, dec: 0.33, pct: 33.33, repeating: true, repDigits: '33', intPart: '0.' },
            { num: 2, den: 3, dec: 0.66, pct: 66.66, repeating: true, repDigits: '66', intPart: '0.' },
            { num: 4, den: 3, dec: 1.33, pct: 133.33, repeating: true, repDigits: '33', intPart: '1.' },
            { num: 5, den: 3, dec: 1.66, pct: 166.66, repeating: true, repDigits: '66', intPart: '1.' },
            // fourths
            { num: 1, den: 4, dec: 0.25, pct: 25 },
            { num: 3, den: 4, dec: 0.75, pct: 75 },
            { num: 5, den: 4, dec: 1.25, pct: 125 },
            { num: 7, den: 4, dec: 1.75, pct: 175 },
            // fifths
            { num: 1, den: 5, dec: 0.2, pct: 20 },
            { num: 2, den: 5, dec: 0.4, pct: 40 },
            { num: 3, den: 5, dec: 0.6, pct: 60 },
            { num: 4, den: 5, dec: 0.8, pct: 80 },
            { num: 6, den: 5, dec: 1.2, pct: 120 },
            { num: 7, den: 5, dec: 1.4, pct: 140 },
            // eighths (3 decimals)
            { num: 1, den: 8, dec: 0.125, pct: 12.5 },
            { num: 3, den: 8, dec: 0.375, pct: 37.5 },
            { num: 5, den: 8, dec: 0.625, pct: 62.5 },
            { num: 7, den: 8, dec: 0.875, pct: 87.5 },
            { num: 9, den: 8, dec: 1.125, pct: 112.5 },
            { num: 11, den: 8, dec: 1.375, pct: 137.5 },
            // ninths (repeating)
            { num: 1, den: 9, dec: 0.11, pct: 11.11, repeating: true, repDigits: '11', intPart: '0.' },
            { num: 2, den: 9, dec: 0.22, pct: 22.22, repeating: true, repDigits: '22', intPart: '0.' },
            { num: 4, den: 9, dec: 0.44, pct: 44.44, repeating: true, repDigits: '44', intPart: '0.' },
            { num: 5, den: 9, dec: 0.55, pct: 55.55, repeating: true, repDigits: '55', intPart: '0.' },
            { num: 7, den: 9, dec: 0.77, pct: 77.77, repeating: true, repDigits: '77', intPart: '0.' },
            { num: 8, den: 9, dec: 0.88, pct: 88.88, repeating: true, repDigits: '88', intPart: '0.' },
            { num: 10, den: 9, dec: 1.11, pct: 111.11, repeating: true, repDigits: '11', intPart: '1.' },
            // tenths
            { num: 1, den: 10, dec: 0.1, pct: 10 },
            { num: 3, den: 10, dec: 0.3, pct: 30 },
            { num: 7, den: 10, dec: 0.7, pct: 70 },
            { num: 9, den: 10, dec: 0.9, pct: 90 },
            { num: 11, den: 10, dec: 1.1, pct: 110 },
            { num: 13, den: 10, dec: 1.3, pct: 130 },
            // hundredths
            { num: 1, den: 100, dec: 0.01, pct: 1 },
            { num: 3, den: 100, dec: 0.03, pct: 3 },
            { num: 7, den: 100, dec: 0.07, pct: 7 },
            { num: 13, den: 100, dec: 0.13, pct: 13 },
            { num: 27, den: 100, dec: 0.27, pct: 27 },
            { num: 43, den: 100, dec: 0.43, pct: 43 },
            { num: 67, den: 100, dec: 0.67, pct: 67 },
            { num: 89, den: 100, dec: 0.89, pct: 89 },
            { num: 123, den: 100, dec: 1.23, pct: 123 },
            { num: 150, den: 100, dec: 1.5, pct: 150 },
            // thousandths
            { num: 1, den: 1000, dec: 0.001, pct: 0.1 },
            { num: 7, den: 1000, dec: 0.007, pct: 0.7 },
            { num: 25, den: 1000, dec: 0.025, pct: 2.5 },
            { num: 125, den: 1000, dec: 0.125, pct: 12.5 },
            { num: 375, den: 1000, dec: 0.375, pct: 37.5 },
            { num: 625, den: 1000, dec: 0.625, pct: 62.5 },
            { num: 1250, den: 1000, dec: 1.25, pct: 125 }
        ];
        
        // Helper to format decimal display (with overline for repeating)
        function formatDecimalDisplay(item) {
            if (item.repeating && item.repDigits) {
                return item.intPart + '<span class="repeating">' + item.repDigits + '</span>';
            }
            return item.dec.toString();
        }
        
        let conversionData = {};
        
        function generateFracDec() {
            const item = benchmarkConversions[Math.floor(Math.random() * benchmarkConversions.length)];
            const direction = Math.random() < 0.5 ? 'fracToDec' : 'decToFrac';
            
            conversionData = { ...item, direction };
            
            if (direction === 'fracToDec') {
                showInputType('single');
                problemEl.textContent = 'Convert to decimal:';
                fractionProblemEl.style.display = 'flex';
                fractionProblemEl.innerHTML = makeFractionHTML(item.num, item.den);
                correctAnswer = item.dec;
                if (item.repeating) {
                    solutionEl.innerHTML = '<span class="hint-text">Enter decimal to 2+ places (e.g., 0.33)</span>';
                } else {
                    solutionEl.innerHTML = '<span class="hint-text">Enter decimal (e.g., 0.25)</span>';
                }
            } else {
                showInputType('fraction');
                problemEl.textContent = 'Convert to fraction (reduced):';
                fractionProblemEl.style.display = 'none';
                problemEl.innerHTML = 'Convert to fraction (reduced):<br><span style="font-size: 2rem; font-family: monospace;">' + formatDecimalDisplay(item) + '</span>';
                // For reduced form, need to calculate
                const g = gcd(item.num, item.den);
                correctNumerator = item.num / g;
                correctDenominator = item.den / g;
            }
            
//             pageTitle.textContent = 'Fraction ↔ Decimal';
        }
        
        function generateFracDecPct() {
            const item = benchmarkConversions[Math.floor(Math.random() * benchmarkConversions.length)];
            const directions = ['fracToDec', 'decToFrac', 'fracToPct', 'pctToFrac', 'decToPct', 'pctToDec'];
            const direction = directions[Math.floor(Math.random() * directions.length)];
            
            conversionData = { ...item, direction };
            fractionProblemEl.style.display = 'none';
            
            // For reduced form
            const g = gcd(item.num, item.den);
            const reducedNum = item.num / g;
            const reducedDen = item.den / g;
            
            if (direction === 'fracToDec') {
                showInputType('single');
                problemEl.textContent = 'Convert to decimal:';
                fractionProblemEl.style.display = 'flex';
                fractionProblemEl.innerHTML = makeFractionHTML(item.num, item.den);
                correctAnswer = item.dec;
                if (item.repeating) {
                    solutionEl.innerHTML = '<span class="hint-text">Enter decimal to 2+ places</span>';
                } else {
                    solutionEl.innerHTML = '<span class="hint-text">Enter decimal (e.g., 0.25)</span>';
                }
            } else if (direction === 'decToFrac') {
                showInputType('fraction');
                problemEl.innerHTML = 'Convert to fraction (reduced):<br><span style="font-size: 2rem; font-family: monospace;">' + formatDecimalDisplay(item) + '</span>';
                correctNumerator = reducedNum;
                correctDenominator = reducedDen;
            } else if (direction === 'fracToPct') {
                showInputType('single');
                problemEl.textContent = 'Convert to percent:';
                fractionProblemEl.style.display = 'flex';
                fractionProblemEl.innerHTML = makeFractionHTML(item.num, item.den);
                correctAnswer = item.pct;
                solutionEl.innerHTML = '<span class="hint-text">Enter percent (e.g., 25 for 25%)</span>';
            } else if (direction === 'pctToFrac') {
                showInputType('fraction');
                problemEl.innerHTML = 'Convert to fraction (reduced):<br><span style="font-size: 2rem; font-family: monospace;">' + item.pct + '%</span>';
                correctNumerator = reducedNum;
                correctDenominator = reducedDen;
            } else if (direction === 'decToPct') {
                showInputType('single');
                problemEl.innerHTML = 'Convert to percent:<br><span style="font-size: 2rem; font-family: monospace;">' + formatDecimalDisplay(item) + '</span>';
                correctAnswer = item.pct;
                solutionEl.innerHTML = '<span class="hint-text">Enter percent (e.g., 25 for 25%)</span>';
            } else if (direction === 'pctToDec') {
                showInputType('single');
                problemEl.innerHTML = 'Convert to decimal:<br><span style="font-size: 2rem; font-family: monospace;">' + item.pct + '%</span>';
                correctAnswer = item.dec;
                if (item.repeating) {
                    solutionEl.innerHTML = '<span class="hint-text">Enter decimal to 2+ places</span>';
                } else {
                    solutionEl.innerHTML = '<span class="hint-text">Enter decimal (e.g., 0.25)</span>';
                }
            }
            
//             pageTitle.textContent = 'Fraction ↔ Decimal ↔ Percent';
        }
        
        function buildConversionExplanation() {
            const d = conversionData;
            const g = gcd(d.num, d.den);
            const reducedNum = d.num / g;
            const reducedDen = d.den / g;
            
            let html = '<div class="solution-inner">';
            
            if (d.direction === 'pctToDec') {
                // 0.1% → decimal: show 0.1% = 0.1/100 = 1/1000 = 0.001
                html += '<div class="solution-line solution-fractions">';
                html += '<span>' + d.pct + '%</span>';
                html += '<span class="solution-op">=</span>';
                html += makeSolutionFractionHTML(d.pct, 100);
                if (d.pct !== reducedNum || 100 !== reducedDen) {
                    html += '<span class="solution-op">=</span>';
                    html += makeSolutionFractionHTML(reducedNum, reducedDen);
                }
                html += '<span class="solution-op">=</span>';
                html += '<span class="sol-frac final" style="flex-direction: row;"><span>' + formatDecimalDisplay(d) + '</span></span>';
                html += '</div>';
                
            } else if (d.direction === 'pctToFrac') {
                // 0.1% → fraction: show 0.1% = 0.1/100 → multiply to clear decimal
                html += '<div class="solution-line solution-fractions">';
                html += '<span>' + d.pct + '%</span>';
                html += '<span class="solution-op">=</span>';
                html += makeSolutionFractionHTML(d.pct, 100);
                if (d.pct % 1 !== 0) {
                    // Has decimal, show multiplying to clear
                    const mult = d.pct < 1 ? 1000 : (d.pct < 10 ? 100 : 10);
                    html += '<span class="solution-op">→</span>';
                    html += '<span class="multiply-by">×' + mult + '/×' + mult + '</span>';
                }
                html += '<span class="solution-op">=</span>';
                html += makeSolutionFractionHTML(reducedNum, reducedDen, true);
                html += '</div>';
                
            } else if (d.direction === 'decToFrac') {
                // 0.001 → fraction: show decimal = fraction
                html += '<div class="solution-line solution-fractions">';
                html += '<span>' + formatDecimalDisplay(d) + '</span>';
                html += '<span class="solution-op">=</span>';
                html += makeSolutionFractionHTML(reducedNum, reducedDen, true);
                html += '</div>';
                
            } else if (d.direction === 'fracToDec') {
                // 1/1000 → decimal: show fraction = decimal
                html += '<div class="solution-line solution-fractions">';
                html += makeSolutionFractionHTML(reducedNum, reducedDen);
                html += '<span class="solution-op">=</span>';
                html += '<span class="sol-frac final" style="flex-direction: row;"><span>' + formatDecimalDisplay(d) + '</span></span>';
                html += '</div>';
                
            } else if (d.direction === 'fracToPct') {
                // 1/1000 → percent: show fraction = decimal = percent
                html += '<div class="solution-line solution-fractions">';
                html += makeSolutionFractionHTML(reducedNum, reducedDen);
                html += '<span class="solution-op">=</span>';
                html += '<span>' + formatDecimalDisplay(d) + '</span>';
                html += '<span class="solution-op">=</span>';
                html += '<span class="sol-frac final" style="flex-direction: row;"><span>' + d.pct + '%</span></span>';
                html += '</div>';
                
            } else if (d.direction === 'decToPct') {
                // 0.001 → percent: show decimal × 100 = percent
                html += '<div class="solution-line solution-fractions">';
                html += '<span>' + formatDecimalDisplay(d) + '</span>';
                html += '<span class="solution-op">×</span>';
                html += '<span>100</span>';
                html += '<span class="solution-op">=</span>';
                html += '<span class="sol-frac final" style="flex-direction: row;"><span>' + d.pct + '%</span></span>';
                html += '</div>';
            }
            
            if (d.repeating) {
                html += '<div class="solution-line" style="font-size: 0.85em; opacity: 0.7; margin-top: 0.5rem;">(repeating decimal)</div>';
            }
            
            html += '</div>';
            return html;
        }
        
        // ===== CHECK FUNCTIONS FOR NEW INPUT TYPES =====
        function checkFractionInput() {
            if (waitingForContinue) return;
            
            const userNum = parseInt(numeratorInput.value.trim());
            const userDen = parseInt(denominatorInput.value.trim());
            
            if (isNaN(userNum) || isNaN(userDen)) return;
            
            const isCorrect = (userNum === correctNumerator && userDen === correctDenominator);
            
            if (isCorrect) {
                correctCount++;
                correctCountEl.textContent = correctCount;
                resultEl.textContent = '✓ Correct!';
                resultEl.className = 'result correct';
            } else {
                wrongCount++;
                wrongCountEl.textContent = wrongCount;
                resultEl.textContent = '✗ Incorrect';
                resultEl.className = 'result wrong';
            }
            
            resultEl.style.display = 'block';
            numeratorInput.disabled = true;
            denominatorInput.disabled = true;
            
            // Use appropriate explanation based on drill type
            if (currentDrill === 'fracDec' || currentDrill === 'fracDecPct') {
                solutionEl.innerHTML = buildConversionExplanation();
            } else {
                solutionEl.innerHTML = buildFractionExplanation();
            }
            
            waitingForContinue = true;
            continueBtn.style.display = 'block';
            continueBtn.focus();
        }
        
        function checkTwoBoxExp() {
            if (waitingForContinue) return;
            
            const userBase = parseInt(baseInput.value.trim());
            const userExp = parseInt(expInput.value.trim());
            
            if (isNaN(userBase) || isNaN(userExp)) return;
            
            // Accept ANY valid base^exp that equals the target value
            const targetValue = Math.pow(correctBase, correctExp);
            const userValue = Math.pow(userBase, userExp);
            const isCorrect = (userValue === targetValue && userBase > 1 && userExp > 0);
            
            if (isCorrect) {
                correctCount++;
                correctCountEl.textContent = correctCount;
                resultEl.textContent = '✓ Correct!';
                resultEl.className = 'result correct';
            } else {
                wrongCount++;
                wrongCountEl.textContent = wrongCount;
                resultEl.textContent = '✗ Incorrect';
                resultEl.className = 'result wrong';
            }
            
            resultEl.style.display = 'block';
            baseInput.disabled = true;
            expInput.disabled = true;
            
            // Show the user's answer if correct, otherwise show expected
            if (isCorrect) {
                solutionEl.innerHTML = '<div class="solution-inner"><div class="solution-line">' + userBase + '<sup>' + userExp + '</sup> = ' + targetValue + '</div></div>';
            } else {
                solutionEl.innerHTML = '<div class="solution-inner"><div class="solution-line">' + correctBase + '<sup>' + correctExp + '</sup> = ' + targetValue + '</div></div>';
            }
            
            waitingForContinue = true;
            continueBtn.style.display = 'block';
            continueBtn.focus();
        }
        
        function checkTwoBoxRange() {
            if (waitingForContinue) return;
            
            const userLow = parseInt(rangeLowInput.value.trim());
            const userHigh = parseInt(rangeHighInput.value.trim());
            
            if (isNaN(userLow) || isNaN(userHigh)) return;
            
            const isCorrect = (userLow === correctLow && userHigh === correctHigh);
            
            if (isCorrect) {
                correctCount++;
                correctCountEl.textContent = correctCount;
                resultEl.textContent = '✓ Correct!';
                resultEl.className = 'result correct';
            } else {
                wrongCount++;
                wrongCountEl.textContent = wrongCount;
                resultEl.textContent = '✗ Incorrect';
                resultEl.className = 'result wrong';
            }
            
            resultEl.style.display = 'block';
            rangeLowInput.disabled = true;
            rangeHighInput.disabled = true;
            
            // Build explanation
            const d = rootEstimationData;
            const symbol = d.type === 'square' ? '√' : '∛';
            let explanation = '<div class="solution-inner">';
            explanation += '<div class="solution-line">' + symbol + d.lower + ' &lt; ' + symbol + d.num + ' &lt; ' + symbol + d.upper + '</div>';
            explanation += '<div class="solution-line">' + d.rootLower + ' &emsp;—&emsp; ' + d.rootUpper + '</div>';
            explanation += '</div>';
            solutionEl.innerHTML = explanation;
            
            waitingForContinue = true;
            continueBtn.style.display = 'block';
            continueBtn.focus();
        }
        
        function checkMultipleChoice(choice) {
            if (waitingForContinue) return;
            
            const letters = ['A', 'B', 'C', 'D', 'E'];
            const idx = letters.indexOf(choice);
            if (idx === -1) return; // Invalid choice
            
            let isCorrect;
            
            // Check if we're using mcChoices array (exponent rules) or correctChoice (stats/divisibility)
            if (mcChoices && mcChoices.length > 0 && mcChoices[0].hasOwnProperty('isCorrect')) {
                // Exponent rules format
                isCorrect = mcChoices[idx].isCorrect;
                mcBtns.forEach((btn, i) => {
                    btn.disabled = true;
                    if (mcChoices[i] && mcChoices[i].isCorrect) {
                        btn.classList.add('correct');
                    }
                });
            } else {
                // Stats/divisibility format - using correctChoice
                isCorrect = (choice === correctChoice);
                mcBtns.forEach((btn, i) => {
                    if (btn.style.display !== 'none') {
                        btn.disabled = true;
                        if (letters[i] === correctChoice) {
                            btn.classList.add('correct');
                        }
                    }
                });
            }
            
            if (!isCorrect) {
                mcBtns[idx].classList.add('wrong');
            }
            
            if (isCorrect) {
                correctCount++;
                correctCountEl.textContent = correctCount;
                resultEl.textContent = '✓ Correct!';
                resultEl.className = 'result correct';
            } else {
                wrongCount++;
                wrongCountEl.textContent = wrongCount;
                resultEl.textContent = '✗ Incorrect';
                resultEl.className = 'result wrong';
            }
            
            resultEl.style.display = 'block';
            
            // Show explanation
            if (currentDrill === 'stats' && statsExplanationData.type === 'stdDev') {
                solutionEl.innerHTML = '<div class="solution-inner"><div class="solution-line">' + statsExplanationData.reason + '</div></div>';
            } else if (currentDrill === 'estimateMult') {
                solutionEl.innerHTML = buildEstimateMultExplanation();
            } else if (currentExpRuleExplanation) {
                solutionEl.innerHTML = '<div class="solution-inner">' + currentExpRuleExplanation + '</div>';
            }
            
            waitingForContinue = true;
            continueBtn.style.display = 'block';
            continueBtn.focus();
        }

        
        function checkAnswer() {
            if (waitingForContinue) return;
            
            // Handle decimal answers for rounding, stats, and conversions
            let userAnswer;
            const inputVal = answerInput.value.trim();
            const isConversion = (currentDrill === 'fracDec' || currentDrill === 'fracDecPct');
            if (currentDrill === 'rounding' || currentDrill === 'stats' || isConversion) {
                userAnswer = parseFloat(inputVal);
            } else {
                // Use parseFloat so decimal inputs dont get truncated
                userAnswer = parseFloat(inputVal);
            }
            if (isNaN(userAnswer)) return;
            
            // Check if this is an estimation drill
            const isEstimation = (currentDrill === 'estimateAdd' || currentDrill === 'estimateSub');
            
            let isCorrect;
            let feedbackText;
            
            if (isEstimation) {
                // Estimation allows tolerance
                const diff = Math.abs(userAnswer - correctAnswer);
                if (diff === 0) {
                    isCorrect = true;
                    feedbackText = '✓ Exact!';
                } else if (diff <= 5) {
                    isCorrect = true;
                    feedbackText = '✓ Very close! (Actual: ' + correctAnswer + ')';
                } else if (diff <= 10) {
                    isCorrect = true;
                    feedbackText = '✓ Good estimate! (Actual: ' + correctAnswer + ')';
                } else {
                    isCorrect = false;
                    feedbackText = '✗ Too far off — Actual was ' + correctAnswer;
                }
            } else if (currentDrill === 'stats') {
                // Stats allows small tolerance for decimals
                isCorrect = Math.abs(userAnswer - correctAnswer) < 0.01;
                feedbackText = isCorrect ? '✓ Correct!' : '✗ Wrong — Answer was ' + formatNumber(correctAnswer);
            } else if (currentDrill === 'fracDec' || currentDrill === 'fracDecPct') {
                // Conversions checking
                let isMatch = false;
                const dir = conversionData.direction;
                const isDecimalAnswer = (dir === 'fracToDec' || dir === 'pctToDec');
                const isPercentAnswer = (dir === 'fracToPct' || dir === 'decToPct');
                
                if (conversionData.repeating && isDecimalAnswer) {
                    // For repeating decimals, compare to actual fraction value
                    const userStr = inputVal;
                    const decimalPlaces = userStr.includes('.') ? userStr.split('.')[1].length : 0;
                    if (decimalPlaces >= 2) {
                        // Compare to actual computed value (num/den), not stored truncated value
                        const actualValue = conversionData.num / conversionData.den;
                        const tolerance = Math.pow(10, -(decimalPlaces));
                        isMatch = Math.abs(userAnswer - actualValue) < tolerance;
                    }
                } else if (conversionData.repeating && isPercentAnswer) {
                    // For repeating decimals converted to percent (33.33%), allow 0.5 tolerance
                    const actualPct = (conversionData.num / conversionData.den) * 100;
                    isMatch = Math.abs(userAnswer - actualPct) < 0.5;
                } else {
                    // For terminating decimals, need close match
                    isMatch = Math.abs(userAnswer - correctAnswer) < 0.001;
                }
                isCorrect = isMatch;
                // For wrong answers, show the properly formatted decimal (with overline for repeating)
                if (isCorrect) {
                    feedbackText = '✓ Correct!';
                } else {
                    feedbackText = '✗ Wrong — Answer was ' + (conversionData.repeating && isDecimalAnswer ? conversionData.dec + '...' : correctAnswer);
                }
            } else {
                isCorrect = userAnswer === correctAnswer;
                feedbackText = isCorrect ? '✓ Correct!' : '✗ Wrong — Answer was ' + correctAnswer;
            }
            
            if (isCorrect) {
                correctCount++;
                correctCountEl.textContent = correctCount;
                resultEl.textContent = feedbackText;
                resultEl.className = 'result correct';
            } else {
                wrongCount++;
                wrongCountEl.textContent = wrongCount;
                resultEl.textContent = feedbackText;
                resultEl.className = 'result wrong';
            }
            
            resultEl.style.display = 'block';
            
            if (currentDrill === 'addition') {
                solutionEl.innerHTML = buildAdditionSolution();
            } else if (currentDrill === 'subtraction') {
                solutionEl.innerHTML = buildSubtractionSolution();
            } else if (currentDrill === 'multiplication1x2') {
                solutionEl.innerHTML = buildMultiplication1x2Solution();
            } else if (currentDrill === 'multiplication2x2') {
                solutionEl.innerHTML = buildMultiplication2x2Solution();
            } else if (currentDrill === 'division') {
                solutionEl.innerHTML = buildDivisionSolution();
            } else if (currentDrill === 'rounding') {
                solutionEl.innerHTML = buildRoundingSolution();
            } else if (currentDrill === 'tables') {
                // Simple solution for tables: problem = answer
                solutionEl.innerHTML = '<div class="solution-inner"><div class="solution-line">' + window.tablesProblemDisplay + ' = <span class="answer-final" style="display: inline;">' + correctAnswer + '</span></div></div>';
            } else if (currentDrill === 'estimateAdd') {
                solutionEl.innerHTML = buildEstimateAddSolution();
            } else if (currentDrill === 'estimateSub') {
                solutionEl.innerHTML = buildEstimateSubSolution();
            } else if (currentDrill === 'stats') {
                solutionEl.innerHTML = buildStatsExplanation();
            } else if (currentDrill === 'fractions') {
                solutionEl.innerHTML = buildFractionExplanation();
            } else if (currentDrill === 'fracDec' || currentDrill === 'fracDecPct') {
                solutionEl.innerHTML = buildConversionExplanation();
            }
            
            answerInput.disabled = true;
            continueBtn.style.display = 'inline-block';
            waitingForContinue = true;
        }
        
        // ===== NEXT QUESTION =====
        function goNext() {
            currentQuestionNumber++;
            
            if (isTimedMode) {
                // In timed mode, track total questions attempted
                totalQuestions = currentQuestionNumber;
                
                // Check if time has expired
                if (timeExpired) {
                    stopTimer();
                    finalScoreEl.textContent = correctCount + ' correct, ' + wrongCount + ' wrong out of ' + totalQuestions + ' in ' + formatTime(elapsedSeconds);
                    showScreen(resultsScreen);
                    return;
                }
            } else {
                // In question mode, decrement remaining
                questionsLeft--;
                remainingEl.textContent = questionsLeft;
                
                if (questionsLeft <= 0) {
                    finalScoreEl.textContent = correctCount + ' correct, ' + wrongCount + ' wrong out of ' + totalQuestions;
                    showScreen(resultsScreen);
                    return;
                }
            }
            
            newProblem();
        }
        
        // ===== EVENT LISTENERS =====
        answerInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (!waitingForContinue) {
                    checkAnswer();
                }
            }
        });
        
        continueBtn.addEventListener('click', function(e) {
            e.preventDefault();
            goNext();
        });
    </script>
</body>
</html>
